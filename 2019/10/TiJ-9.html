<!DOCTYPE html><html lang="zh-hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" /><title>Thinking in Java摘抄（类型信息） | Peninsula</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Thinking in Java摘抄（类型信息）" /><meta name="author" content="jizhizhu" /><meta property="og:locale" content="en_US" /><meta name="description" content="类型信息" /><meta property="og:description" content="类型信息" /><link rel="canonical" href="http://laixinz.com//2019/10/TiJ-9.html" /><meta property="og:url" content="http://laixinz.com//2019/10/TiJ-9.html" /><meta property="og:site_name" content="Peninsula" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-19T00:00:00+08:00" /> <script type="application/ld+json"> {"url":"http://laixinz.com//2019/10/TiJ-9.html","author":{"@type":"Person","name":"jizhizhu"},"headline":"Thinking in Java摘抄（类型信息）","dateModified":"2019-10-19T00:00:00+08:00","datePublished":"2019-10-19T00:00:00+08:00","description":"类型信息","mainEntityOfPage":{"@type":"WebPage","@id":"http://laixinz.com//2019/10/TiJ-9.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="stylesheet" href="/public/css/styles.css"><link rel="stylesheet" href="/public/plugins/fancybox/jquery.fancybox.min.css" media="all"><link rel="stylesheet" href="/public/fonts/caomei/style.css" media="all"><style> .content a, .related-posts li a:hover { color: #dc322f; } ::selection { color: #fff; background: #dc322f; } ::-moz-selection { color: #fff; background: #dc322f; }</style><link rel="icon" type="image/jpeg" href="/public/images/icons/launcher-icon-128x128.jpeg"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/images/icons/launcher-icon-152x152.jpeg"><link rel="alternate" type="application/feed+xml" title="Peninsula" href="/feed.xml"><link rel="manifest" href="/manifest.json"> <script src="/public/js/jquery.min.js"></script> <script src="/public/js/highlight.min.js"></script> <script src="/public/plugins/fancybox/jquery.fancybox.min.js"></script> <script async> (function (i, s, o, g, r, a, m) { i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m) })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <script> var _hmt = _hmt || []; (function () { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></head><body class="theme-base-08"><main class="content container"><article class="post"><h1 class="post-title">Thinking in Java摘抄（类型信息）</h1><div class="post-date"> <span>发表于 <time datetime="2019-10-19T00:00:00+08:00">2019年10月19日</time> &middot;</span> 阅读量 <span id="busuanzi_value_page_pv">加载中...</span></div><hr class="post-divide"><h2 id="类型信息">类型信息</h2><ul><li>RTTI（RunTime Type Information，运行时类型信息）能够在程序运行时发现和使用类型信息。本章将讨论 Java 是如何在运行时识别对象和类信息的。主要有两种方式：<ol><li>“传统的” RTTI：假定我们在编译时已经知道了所有的类型；</li><li>“反射”机制：允许我们在运行时发现和使用类的信息。</li></ol></li><li><p>Java还提供了另一种方法来生成类对象的引用：<strong>类字面常量</strong>。对上述程序来说，就像这样：<code class="highlighter-rouge">FancyToy.class;</code>。这样做不仅更简单，而且更安全，因为它在编译时就会受到检查（因此不必放在<code class="highlighter-rouge">try</code>语句块中）。并且它根除了对 <code class="highlighter-rouge">forName()</code> 方法的调用，所以效率更高。</p><p>类字面常量不仅不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装器类，还有一个标准字段 <code class="highlighter-rouge">TYPE</code>。<code class="highlighter-rouge">TYPE</code>字段是一个引用，指向对应的基本数据类型的 <code class="highlighter-rouge">Class</code> 对象，如下所示：</p><blockquote><table><thead><tr><th>…等价于…</th><th> </th></tr></thead><tbody><tr><td>boolean.class</td><td>Boolean.TYPE</td></tr><tr><td>char.class</td><td>Character.TYPE</td></tr><tr><td>byte.class</td><td>Byte.TYPE</td></tr><tr><td>short.class</td><td>Short.TYPE</td></tr><tr><td>int.class</td><td>Integer.TYPE</td></tr><tr><td>long.class</td><td>Long.TYPE</td></tr><tr><td>float.class</td><td>Float.TYPE</td></tr><tr><td>double.class</td><td>Double.TYPE</td></tr><tr><td>void.class</td><td>Void.TYPE</td></tr></tbody></table><p>建议是使用 <code class="highlighter-rouge">.class</code> 的形式，以保持与普通类的一致性。</p><p>注意，有一点很有趣：当使用 <code class="highlighter-rouge">.class</code> 来创建对 <code class="highlighter-rouge">Class</code> 对象的引用时，不会自动地初始化该<code class="highlighter-rouge">Class</code> 对象。为了使用类而做的准备工作实际包含三个步骤：</p><ol><li><strong>加载</strong>，这是由类加载器执行的。该步骤将查找字节码（通常在 classpath 所指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个 <code class="highlighter-rouge">Class</code> 对象。</li><li><strong>链接</strong>。在链接阶段将验证类中的字节码，为 <code class="highlighter-rouge">static</code> 域分配存储空间，并且如果需要的话，将解析这个类创建的对其他类的所有引用。</li><li><strong>初始化</strong>。如果该类具有超类，则对其进行初始化，执行 <code class="highlighter-rouge">static</code> 初始化器和 <code class="highlighter-rouge">static</code> 初始化块。</li></ol><p>初始化被延迟到了对 <code class="highlighter-rouge">static</code> 方法（构造器隐式地是 <code class="highlighter-rouge">static</code> 的）或者非常数 <code class="highlighter-rouge">static</code> 域进行首次引用时才执行：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Initable</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">STATIC_FINAL</span> <span class="o">=</span> <span class="mi">47</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">STATIC_FINAL2</span> <span class="o">=</span>
        <span class="nc">ClassInitialization</span><span class="o">.</span><span class="na">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Initializing Initable"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Initable2</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">staticNonFinal</span> <span class="o">=</span> <span class="mi">147</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Initializing Initable2"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Initable3</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">staticNonFinal</span> <span class="o">=</span> <span class="mi">74</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Initializing Initable3"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ClassInitialization</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">47</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span>
    <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">Class</span> <span class="n">initable</span> <span class="o">=</span> <span class="nc">Initable</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After creating Initable ref"</span><span class="o">);</span>
        <span class="c1">// Does not trigger initialization:</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Initable</span><span class="o">.</span><span class="na">STATIC_FINAL</span><span class="o">);</span>
        <span class="c1">// Does trigger initialization:</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Initable</span><span class="o">.</span><span class="na">STATIC_FINAL2</span><span class="o">);</span>
        <span class="c1">// Does trigger initialization:</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Initable2</span><span class="o">.</span><span class="na">staticNonFinal</span><span class="o">);</span>
        <span class="nc">Class</span> <span class="n">initable3</span> <span class="o">=</span> <span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"Initable3"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After creating Initable3 ref"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Initable3</span><span class="o">.</span><span class="na">staticNonFinal</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="err">输出结果：</span>
<span class="nc">After</span> <span class="n">creating</span> <span class="nc">Initable</span> <span class="n">ref</span>
<span class="mi">47</span>
<span class="nc">Initializing</span> <span class="nc">Initable</span>
<span class="mi">258</span>
<span class="nc">Initializing</span> <span class="nc">Initable2</span>
<span class="mi">147</span>
<span class="nc">Initializing</span> <span class="nc">Initable3</span>
<span class="nc">After</span> <span class="n">creating</span> <span class="nc">Initable3</span> <span class="n">ref</span>
<span class="mi">74</span>
</code></pre></div></div><p>初始化有效地实现了尽可能的“惰性”，从对 <code class="highlighter-rouge">initable</code> 引用的创建中可以看到，仅使用 <code class="highlighter-rouge">.class</code> 语法来获得对类对象的引用不会引发初始化。但与此相反，使用 <code class="highlighter-rouge">Class.forName()</code> 来产生 <code class="highlighter-rouge">Class</code> 引用会立即就进行初始化，如 <code class="highlighter-rouge">initable3</code>。</p><p>如果一个 <code class="highlighter-rouge">static final</code> 值是“编译期常量”（如 <code class="highlighter-rouge">Initable.staticFinal</code>），那么这个值不需要对 <code class="highlighter-rouge">Initable</code> 类进行初始化就可以被读取。但是，如果只是将一个域设置成为 <code class="highlighter-rouge">static</code> 和 <code class="highlighter-rouge">final</code>，还不足以确保这种行为。例如，对 <code class="highlighter-rouge">Initable.staticFinal2</code> 的访问将强制进行类的初始化，因为它不是一个编译期常量。</p><p>如果一个 <code class="highlighter-rouge">static</code> 域不是 <code class="highlighter-rouge">final</code> 的，那么在对它访问时，总是要求在它被读取之前，要先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间），就像在对 <code class="highlighter-rouge">Initable2.staticNonFinal</code> 的访问中所看到的那样。</p></blockquote></li><li><code class="highlighter-rouge">Class.isInstance(obj)</code> 方法提供了一种动态测试对象类型的方法，在某些情况下消除了对 <code class="highlighter-rouge">instanceof</code> 表达式的需要。</li><li>在查询类型信息时，以<code class="highlighter-rouge">instanceof</code>的形式（即以<code class="highlighter-rouge">instanceof</code>的形式或<code class="highlighter-rouge">isInstance()</code>的形式，它们产生相同的结果）与直接比较 Class对象有一个很重要的差别： <code class="highlighter-rouge">instanceof</code>保持了类型的概念，它指的是“你是这个类，还是从这个类的派生类？”；另一方面，如果使用 <code class="highlighter-rouge">==</code> 或 <code class="highlighter-rouge">equals()</code> 比较实际的 <code class="highlighter-rouge">Class</code> 对象，则与继承无关 —— 它要么是这个确切的类型，要么不是。</li><li>当使用反射与未知类型的对象交互时，JVM 只是简单地检查这个对象，看它属于哪个特定的类（就像RTTI那样）。在对其执行任何操作之前，必须先加载那个类的 <code class="highlighter-rouge">Class</code> 对象。因此，那个类的 <code class="highlighter-rouge">.class</code> 文件对于 JVM 来说必须是可获取的：要么在本地计算机上，要么可以通过网络取得。所以RTTI 和反射之间真正的区别只在于，对 RTTI 来说，编译器在编译时打开和检查 <code class="highlighter-rouge">.class</code> 文件。（换句话说，我们可以用“普通”方式调用对象的所有方法。）而对于反射机制来说，<code class="highlighter-rouge">.class</code> 文件在编译时是不可获取的，所以是在运行时打开和检查<code class="highlighter-rouge">.class</code> 文件。</li><li>没有任何方式可以阻止反射到达并调用那些非公共访问权限的方法；对于域来说也是如此，即便是private域，但是final域实际上在遭遇反射修改时是安全的。运行时系统会在不抛异常的情况下接受任何修改的尝试，但是实际上不会发生任何修改。</li></ul></article><span class="tags"> 标签： <a href="/tags.html#Tij" title="Tij">#Tij</a>&nbsp; </span><div style="margin-top: 1rem;padding-left: 0;"><hr class="post-divide" /></div><div class="post-pagination"> <a class="float-left" href="/2019/10/TiJ-8.html" title="Thinking in Java摘抄（字符串）">« Thinking in Java摘抄（字符串）</a></div><div class="clearfix"></div></main><div id="_backdrop"></div><a id="_menu" href="#_sidebar">☰</a><aside id="_sidebar" class="sidebar" style="background-image:url('/public/images/mountains.jpg')" ><div class="container sidebar-sticky"><div class="sidebar-about"><h1> <a href="" title="Peninsula"> Peninsula </a></h1><p>关于编程、生活、游戏和我的一些思考。</p></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">主页</a> <a class="sidebar-nav-item" href="/tags.html">标签</a> <a class="sidebar-nav-item" href="/links.html">友链</a> <a class="sidebar-nav-item" href="/about.html">关于</a></nav><div class="sidebar-social"> <a href="https://github.com/jizhizhu" title="Github" target="_blank" data-no-instant><span class="icon czs-github-logo"></span></a> <a href="/feed.xml"><span class="icon czs-rss"></span></a></div></div></aside><script src="/public/js/drawer.min.js"></script> <script src="/public/js/instantclick.min.js" data-no-instant></script> <script type="text/javascript"> $(document).ready(function () { $("p img").each(function () { var wrapA = "<a data-fancybox='gallery' href='" + this.src + "'></a>"; $(this).wrapAll(wrapA); }); }); var isLoad = false; InstantClick.on('change', function (isInitialLoad) { var blocks = document.querySelectorAll('pre code'); for (var i = 0; i < blocks.length; i++) { hljs.highlightBlock(blocks[i]); } if (isInitialLoad === false) { if (typeof ga !== 'undefined') ga('send', 'pageview', location.pathname + location.search); } if (!isLoad) { isLoad = true; $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"); } }); InstantClick.init('mousedown'); /*** * Put your custom script here */ if (navigator.platform.match(/win32/i)) { var cssId = 'webkit-scrollbar'; if (!document.getElementById(cssId)) { var head = document.getElementsByTagName('head')[0]; var style = document.createElement('style'); style.id = cssId; style.innerText = ` ::-webkit-scrollbar { width: 6px; height: 6px; background-color: #fff; } ::-webkit-scrollbar-track { background-color: #fff; } ::-webkit-scrollbar-thumb { background-color: #ccc; border: 1px solid #ddd; } `; head.appendChild(style); } } </script></body></html>