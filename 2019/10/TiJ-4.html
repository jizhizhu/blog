<!DOCTYPE html><html lang="zh-hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" /><title>Thinking in Java摘抄（函数式编程） | Peninsula</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Thinking in Java摘抄（函数式编程）" /><meta name="author" content="jizhizhu" /><meta property="og:locale" content="en_US" /><meta name="description" content="函数式编程" /><meta property="og:description" content="函数式编程" /><link rel="canonical" href="http://laixinz.com//2019/10/TiJ-4.html" /><meta property="og:url" content="http://laixinz.com//2019/10/TiJ-4.html" /><meta property="og:site_name" content="Peninsula" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-12T00:00:00+08:00" /> <script type="application/ld+json"> {"url":"http://laixinz.com//2019/10/TiJ-4.html","author":{"@type":"Person","name":"jizhizhu"},"headline":"Thinking in Java摘抄（函数式编程）","dateModified":"2019-10-12T00:00:00+08:00","datePublished":"2019-10-12T00:00:00+08:00","description":"函数式编程","mainEntityOfPage":{"@type":"WebPage","@id":"http://laixinz.com//2019/10/TiJ-4.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="stylesheet" href="/public/css/styles.css"><link rel="stylesheet" href="/public/plugins/fancybox/jquery.fancybox.min.css" media="all"><link rel="stylesheet" href="/public/fonts/caomei/style.css" media="all"><style> .content a, .related-posts li a:hover { color: #dc322f; } ::selection { color: #fff; background: #dc322f; } ::-moz-selection { color: #fff; background: #dc322f; }</style><link rel="icon" type="image/jpeg" href="/public/images/icons/launcher-icon-128x128.jpeg"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/images/icons/launcher-icon-152x152.jpeg"><link rel="alternate" type="application/feed+xml" title="Peninsula" href="/feed.xml"><link rel="manifest" href="/manifest.json"> <script src="/public/js/jquery.min.js"></script> <script src="/public/js/highlight.min.js"></script> <script src="/public/plugins/fancybox/jquery.fancybox.min.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151331959-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-151331959-1'); </script></head><body class="theme-base-08"><main class="content container"><article class="post"><h1 class="post-title">Thinking in Java摘抄（函数式编程）</h1><div class="post-date"> <span>发表于 <time datetime="2019-10-12T00:00:00+08:00">2019年10月12日</time> &middot;</span> 阅读量 <span id="busuanzi_value_page_pv">加载中...</span> &middot; <a href="http://laixinz.com//2019/10/TiJ-4.html#disqus_thread">评论</a></div><hr class="post-divide"><h2 id="函数式编程">函数式编程</h2><ul><li><p>Java 8 的 Lambda 表达式。由箭头 <code class="highlighter-rouge">-&gt;</code> 分隔开参数和函数体，箭头左边是参数，箭头右侧是从 Lambda 返回的表达式，即函数体。这实现了与定义类、匿名内部类相同的效果，但代码少得多。</p></li><li><p>Java 8 的<strong>方法引用</strong>，由 <code class="highlighter-rouge">::</code> 区分。在 <code class="highlighter-rouge">::</code> 的左边是类或对象的名称，在 <code class="highlighter-rouge">::</code> 的右边是方法的名称，但没有参数列表。</p></li><li><p>Lambda 表达式是使用<strong>最小可能</strong>语法编写的函数定义：</p><ol><li>Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。</li><li>Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。</li></ol><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Description</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">brief</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Body</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">detailed</span><span class="o">(</span><span class="nc">String</span> <span class="n">head</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Multi</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">twoArg</span><span class="o">(</span><span class="nc">String</span> <span class="n">head</span><span class="o">,</span> <span class="nc">Double</span> <span class="n">d</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LambdaExpressions</span> <span class="o">{</span>

  <span class="kd">static</span> <span class="nc">Body</span> <span class="n">bod</span> <span class="o">=</span> <span class="n">h</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="s">" No Parens!"</span><span class="o">;</span> <span class="c1">// [1]</span>

  <span class="kd">static</span> <span class="nc">Body</span> <span class="n">bod2</span> <span class="o">=</span> <span class="o">(</span><span class="n">h</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="s">" More details"</span><span class="o">;</span> <span class="c1">// [2]</span>

  <span class="kd">static</span> <span class="nc">Description</span> <span class="n">desc</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"Short info"</span><span class="o">;</span> <span class="c1">// [3]</span>

  <span class="kd">static</span> <span class="nc">Multi</span> <span class="n">mult</span> <span class="o">=</span> <span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">n</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">h</span> <span class="o">+</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// [4]</span>

  <span class="kd">static</span> <span class="nc">Description</span> <span class="n">moreLines</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="c1">// [5]</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"moreLines()"</span><span class="o">);</span>
    <span class="k">return</span> <span class="s">"from moreLines()"</span><span class="o">;</span>
  <span class="o">};</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bod</span><span class="o">.</span><span class="na">detailed</span><span class="o">(</span><span class="s">"Oh!"</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bod2</span><span class="o">.</span><span class="na">detailed</span><span class="o">(</span><span class="s">"Hi!"</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">desc</span><span class="o">.</span><span class="na">brief</span><span class="o">());</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">mult</span><span class="o">.</span><span class="na">twoArg</span><span class="o">(</span><span class="s">"Pi! "</span><span class="o">,</span> <span class="mf">3.14159</span><span class="o">));</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">moreLines</span><span class="o">.</span><span class="na">brief</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>输出结果：</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Oh! No Parens!
Hi! More details
Short info
Pi! 3.14159
moreLines()
from moreLines()
</code></pre></div></div><blockquote><p>我们从三个接口开始，每个接口都有一个单独的方法（很快就会理解它的重要性）。但是，每个方法都有不同数量的参数，以便演示 Lambda 表达式语法。</p><p>任何 Lambda 表达式的基本语法是：</p><ol><li>参数。</li><li>接着 <code class="highlighter-rouge">-&gt;</code>，可视为“产出”。</li><li><code class="highlighter-rouge">-&gt;</code> 之后的内容都是方法体。</li></ol><ul><li><strong>[1]</strong> 当只用一个参数，可以不需要括号 <code class="highlighter-rouge">()</code>。 然而，这是一个特例。</li><li><strong>[2]</strong> 正常情况使用括号 <code class="highlighter-rouge">()</code> 包裹参数。 为了保持一致性，也可以使用括号 <code class="highlighter-rouge">()</code> 包裹单个参数，虽然这种情况并不常见。</li><li><strong>[3]</strong> 如果没有参数，则必须使用括号 <code class="highlighter-rouge">()</code> 表示空参数列表。</li><li><strong>[4]</strong> 对于多个参数，将参数列表放在括号 <code class="highlighter-rouge">()</code> 中。</li></ul><p>到目前为止，所有 Lambda 表达式方法体都是单行。 该表达式的结果自动成为 Lambda 表达式的返回值，在此处使用 <strong>return</strong> 关键字是非法的。 这是 Lambda 表达式缩写用于描述功能的语法的另一种方式。</p><p><strong>[5]</strong> 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 <strong>return</strong>。</p><p>Lambda 表达式通常比<strong>匿名内部类</strong>产生更易读的代码，因此我们将在本书中尽可能使用它们。</p></blockquote></li><li><p>Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名，后面跟 <code class="highlighter-rouge">::</code> ，然后跟方法名称。(方法引用的小问题：经过测试，当接口方法无返回值，实现的方法只要参数类型一致就可以进行方法调用，也就是说此时实现方法可以有返回值，但因为无法传递返回值所以没有意义；当接口方法有返回值时实现方法的返回值必须一致)</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Callable</span> <span class="o">{</span> <span class="c1">// [1]</span>
  <span class="kt">void</span> <span class="nf">call</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Describe</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// [2]</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodReferences</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// [3]</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Description</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">about</span><span class="o">;</span>
    <span class="nc">Description</span><span class="o">(</span><span class="nc">String</span> <span class="n">desc</span><span class="o">)</span> <span class="o">{</span> <span class="n">about</span> <span class="o">=</span> <span class="n">desc</span><span class="o">;</span> <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">help</span><span class="o">(</span><span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// [4]</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">about</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Helper</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">assist</span><span class="o">(</span><span class="nc">String</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// [5]</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Describe</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Describe</span><span class="o">();</span>
    <span class="nc">Callable</span> <span class="n">c</span> <span class="o">=</span> <span class="nl">d:</span><span class="o">:</span><span class="n">show</span><span class="o">;</span> <span class="c1">// [6]</span>
    <span class="n">c</span><span class="o">.</span><span class="na">call</span><span class="o">(</span><span class="s">"call()"</span><span class="o">);</span> <span class="c1">// [7]</span>

    <span class="n">c</span> <span class="o">=</span> <span class="nl">MethodReferences:</span><span class="o">:</span><span class="n">hello</span><span class="o">;</span> <span class="c1">// [8]</span>
    <span class="n">c</span><span class="o">.</span><span class="na">call</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">);</span>

    <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Description</span><span class="o">(</span><span class="s">"valuable"</span><span class="o">)::</span><span class="n">help</span><span class="o">;</span> <span class="c1">// [9]</span>
    <span class="n">c</span><span class="o">.</span><span class="na">call</span><span class="o">(</span><span class="s">"information"</span><span class="o">);</span>

    <span class="n">c</span> <span class="o">=</span> <span class="nl">Helper:</span><span class="o">:</span><span class="n">assist</span><span class="o">;</span> <span class="c1">// [10]</span>
    <span class="n">c</span><span class="o">.</span><span class="na">call</span><span class="o">(</span><span class="s">"Help!"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>输出结果：</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>call()
Hello, Bob
valuable information
Help!
</code></pre></div></div><blockquote><p><strong>[1]</strong> 我们从单一方法接口开始（同样，你很快就会了解到这一点的重要性）。</p><p><strong>[2]</strong> <code class="highlighter-rouge">show()</code> 的签名（参数类型和返回类型）符合 <strong>Callable</strong> 的 <code class="highlighter-rouge">call()</code> 的签名。</p><p><strong>[3]</strong> <code class="highlighter-rouge">hello()</code> 也符合 <code class="highlighter-rouge">call()</code> 的签名。</p><p><strong>[4]</strong> <code class="highlighter-rouge">help()</code> 也符合，它是静态内部类中的非静态方法。</p><p><strong>[5]</strong> <code class="highlighter-rouge">assist()</code> 是静态内部类中的静态方法。</p><p><strong>[6]</strong> 我们将 <strong>Describe</strong> 对象的方法引用赋值给 <strong>Callable</strong> ，它没有 <code class="highlighter-rouge">show()</code> 方法，而是 <code class="highlighter-rouge">call()</code> 方法。 但是，Java 似乎接受用这个看似奇怪的赋值，因为方法引用符合 <strong>Callable</strong> 的 <code class="highlighter-rouge">call()</code> 方法的签名。</p><p><strong>[7]</strong> 我们现在可以通过调用 <code class="highlighter-rouge">call()</code> 来调用 <code class="highlighter-rouge">show()</code>，因为 Java 将 <code class="highlighter-rouge">call()</code> 映射到 <code class="highlighter-rouge">show()</code>。</p><p><strong>[8]</strong> 这是一个<strong>静态</strong>方法引用。</p><p><strong>[9]</strong> 这是 <strong>[6]</strong> 的另一个版本：对已实例化对象的方法的引用，有时称为<em>绑定方法引用</em>。</p><p><strong>[10]</strong> 最后，获取静态内部类的方法引用的操作与 <strong>[8]</strong> 中外部类方式一样。</p><p>上例只是简短的介绍，我们很快就能看到方法引用的全部变化。</p></blockquote></li><li><p>未绑定的方法引用是指没有关联对象的普通（非静态）方法。 使用未绑定的引用之前，我们必须先提供对象：</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 没有方法引用的对象</span>

<span class="kd">class</span> <span class="nc">X</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"X::f()"</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">MakeString</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">make</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">TransformX</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">transform</span><span class="o">(</span><span class="no">X</span> <span class="n">x</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnboundMethodReference</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// MakeString ms = X::f; // [1]</span>
    <span class="nc">TransformX</span> <span class="n">sp</span> <span class="o">=</span> <span class="nl">X:</span><span class="o">:</span><span class="n">f</span><span class="o">;</span>
    <span class="no">X</span> <span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="no">X</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sp</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">x</span><span class="o">));</span> <span class="c1">// [2]</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">f</span><span class="o">());</span> <span class="c1">// 同等效果</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>输出结果：</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X::f()
X::f()
</code></pre></div></div><blockquote><p>截止目前，我们已经知道了与接口方法同名的方法引用。 在 <strong>[1]</strong>，我们尝试把 <code class="highlighter-rouge">X</code> 的 <code class="highlighter-rouge">f()</code> 方法引用赋值给 <strong>MakeString</strong>。结果：即使 <code class="highlighter-rouge">make()</code> 与 <code class="highlighter-rouge">f()</code> 具有相同的签名，编译也会报“invalid method reference”（无效方法引用）错误。 这是因为实际上还有另一个隐藏的参数：我们的老朋友 <code class="highlighter-rouge">this</code>。 你不能在没有 <code class="highlighter-rouge">X</code> 对象的前提下调用 <code class="highlighter-rouge">f()</code>。 因此，<code class="highlighter-rouge">X :: f</code> 表示未绑定的方法引用，因为它尚未“绑定”到对象。</p><p>要解决这个问题，我们需要一个 <code class="highlighter-rouge">X</code> 对象，所以我们的接口实际上需要一个额外的参数的接口，如上例中的 <strong>TransformX</strong>。 如果将 <code class="highlighter-rouge">X :: f</code> 赋值给 <strong>TransformX</strong>，这在 Java 中是允许的。这次我们需要调整下心里预期——使用未绑定的引用时，函数方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。 理由是：你需要一个对象来调用方法。</p><p><strong>[2]</strong> 的结果有点像脑筋急转弯。 我接受未绑定的引用并对其调用 <code class="highlighter-rouge">transform()</code>，将其传递给 <code class="highlighter-rouge">X</code>，并以某种方式导致对 <code class="highlighter-rouge">x.f()</code> 的调用。 Java 知道它必须采用第一个参数，这实际上就是 <code class="highlighter-rouge">this</code>，并在其上调用方法。</p></blockquote><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 未绑定的方法与多参数的结合运用</span>

<span class="kd">class</span> <span class="nc">This</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">two</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d</span><span class="o">)</span> <span class="o">{}</span>
  <span class="kt">void</span> <span class="nf">three</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{}</span>
  <span class="kt">void</span> <span class="nf">four</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">TwoArgs</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">call2</span><span class="o">(</span><span class="nc">This</span> <span class="n">athis</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">ThreeArgs</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">call3</span><span class="o">(</span><span class="nc">This</span> <span class="n">athis</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">FourArgs</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">call4</span><span class="o">(</span>
    <span class="nc">This</span> <span class="n">athis</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">double</span> <span class="n">d</span><span class="o">,</span> <span class="nc">String</span> <span class="n">s</span><span class="o">,</span> <span class="kt">char</span> <span class="n">c</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MultiUnbound</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TwoArgs</span> <span class="n">twoargs</span> <span class="o">=</span> <span class="nl">This:</span><span class="o">:</span><span class="n">two</span><span class="o">;</span>
    <span class="nc">ThreeArgs</span> <span class="n">threeargs</span> <span class="o">=</span> <span class="nl">This:</span><span class="o">:</span><span class="n">three</span><span class="o">;</span>
    <span class="nc">FourArgs</span> <span class="n">fourargs</span> <span class="o">=</span> <span class="nl">This:</span><span class="o">:</span><span class="n">four</span><span class="o">;</span>
    <span class="nc">This</span> <span class="n">athis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">This</span><span class="o">();</span>
    <span class="n">twoargs</span><span class="o">.</span><span class="na">call2</span><span class="o">(</span><span class="n">athis</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mf">3.14</span><span class="o">);</span>
    <span class="n">threeargs</span><span class="o">.</span><span class="na">call3</span><span class="o">(</span><span class="n">athis</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mf">3.14</span><span class="o">,</span> <span class="s">"Three"</span><span class="o">);</span>
    <span class="n">fourargs</span><span class="o">.</span><span class="na">call4</span><span class="o">(</span><span class="n">athis</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mf">3.14</span><span class="o">,</span> <span class="s">"Four"</span><span class="o">,</span> <span class="sc">'Z'</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>为了说明这一点，我将类命名为 <strong>This</strong> ，函数方法的第一个参数则是 <strong>athis</strong>，但是你应该选择其他名称以防止生产代码混淆。</p></blockquote></li><li><p>你还可以捕获构造函数的引用，然后通过引用调用该构造函数。</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// For "unknown"</span>
  <span class="nc">Dog</span><span class="o">()</span> <span class="o">{</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"stray"</span><span class="o">;</span> <span class="o">}</span>
  <span class="nc">Dog</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">)</span> <span class="o">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">nm</span><span class="o">;</span> <span class="o">}</span>
  <span class="nc">Dog</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">,</span> <span class="kt">int</span> <span class="n">yrs</span><span class="o">)</span> <span class="o">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">nm</span><span class="o">;</span> <span class="n">age</span> <span class="o">=</span> <span class="n">yrs</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">MakeNoArgs</span> <span class="o">{</span>
  <span class="nc">Dog</span> <span class="nf">make</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Make1Arg</span> <span class="o">{</span>
  <span class="nc">Dog</span> <span class="nf">make</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">Make2Args</span> <span class="o">{</span>
  <span class="nc">Dog</span> <span class="nf">make</span><span class="o">(</span><span class="nc">String</span> <span class="n">nm</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CtorReference</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">MakeNoArgs</span> <span class="n">mna</span> <span class="o">=</span> <span class="nl">Dog:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span> <span class="c1">// [1]</span>
    <span class="nc">Make1Arg</span> <span class="n">m1a</span> <span class="o">=</span> <span class="nl">Dog:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>   <span class="c1">// [2]</span>
    <span class="nc">Make2Args</span> <span class="n">m2a</span> <span class="o">=</span> <span class="nl">Dog:</span><span class="o">:</span><span class="k">new</span><span class="o">;</span>  <span class="c1">// [3]</span>

    <span class="nc">Dog</span> <span class="n">dn</span> <span class="o">=</span> <span class="n">mna</span><span class="o">.</span><span class="na">make</span><span class="o">();</span>
    <span class="nc">Dog</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">m1a</span><span class="o">.</span><span class="na">make</span><span class="o">(</span><span class="s">"Comet"</span><span class="o">);</span>
    <span class="nc">Dog</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">m2a</span><span class="o">.</span><span class="na">make</span><span class="o">(</span><span class="s">"Ralph"</span><span class="o">,</span> <span class="mi">4</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><blockquote><p><strong>Dog</strong> 有三个构造函数，函数接口内的 <code class="highlighter-rouge">make()</code> 方法反映了构造函数参数列表（ <code class="highlighter-rouge">make()</code> 方法名称可以不同）。</p><p><strong>注意</strong>我们如何对 <strong>[1]</strong>，<strong>[2]</strong> 和 <strong>[3]</strong> 中的每一个使用 <code class="highlighter-rouge">Dog :: new</code>。 这 3 个构造函数只有一个相同名称：<code class="highlighter-rouge">:: new</code>，但在每种情况下都赋值给不同的接口。编译器可以检测并知道从哪个构造函数引用。</p><p>编译器能识别并调用你的构造函数（ 在本例中为 <code class="highlighter-rouge">make()</code>）。</p></blockquote></li><li><p>Java 8 引入了 <code class="highlighter-rouge">java.util.function</code> 包。它包含一组接口，这些接口是 Lambda 表达式和方法引用的目标类型。 每个接口只包含一个抽象方法，称为函数式方法。</p><p>在编写接口时，可以使用 <code class="highlighter-rouge">@FunctionalInterface</code> 注解强制执行此“函数式方法”模式：</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@FunctionalInterface</span>
<span class="kd">interface</span> <span class="nc">Functional</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">goodbye</span><span class="o">(</span><span class="nc">String</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">interface</span> <span class="nc">FunctionalNoAnn</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">goodbye</span><span class="o">(</span><span class="nc">String</span> <span class="n">arg</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/*
@FunctionalInterface
interface NotFunctional {
  String goodbye(String arg);
  String hello(String arg);
}
产生错误信息:
NotFunctional is not a functional interface
multiple non-overriding abstract methods
found in interface NotFunctional
*/</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">FunctionalAnnotation</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">goodbye</span><span class="o">(</span><span class="nc">String</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="s">"Goodbye, "</span> <span class="o">+</span> <span class="n">arg</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">FunctionalAnnotation</span> <span class="n">fa</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nf">FunctionalAnnotation</span><span class="o">();</span>
    <span class="nc">Functional</span> <span class="n">f</span> <span class="o">=</span> <span class="nl">fa:</span><span class="o">:</span><span class="n">goodbye</span><span class="o">;</span>
    <span class="nc">FunctionalNoAnn</span> <span class="n">fna</span> <span class="o">=</span> <span class="nl">fa:</span><span class="o">:</span><span class="n">goodbye</span><span class="o">;</span>
    <span class="c1">// Functional fac = fa; // Incompatible</span>
    <span class="nc">Functional</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="s">"Goodbye, "</span> <span class="o">+</span> <span class="n">a</span><span class="o">;</span>
    <span class="nc">FunctionalNoAnn</span> <span class="n">fnal</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="s">"Goodbye, "</span> <span class="o">+</span> <span class="n">a</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><blockquote><p><code class="highlighter-rouge">@FunctionalInterface</code> 注解是可选的; Java 在 <code class="highlighter-rouge">main()</code> 中把 <strong>Functional</strong> 和 <strong>FunctionalNoAnn</strong> 都当作函数式接口。 <code class="highlighter-rouge">@FunctionalInterface</code> 的值在 <code class="highlighter-rouge">NotFunctional</code> 的定义中可见：接口中如果有多个方法则会产生编译时错误消息。</p></blockquote><blockquote><p><code class="highlighter-rouge">java.util.function</code> 包旨在创建一组完整的目标接口，使得我们一般情况下不需再定义自己的接口。这主要是因为基本类型会产生一小部分接口。 如果你了解命名模式，顾名思义就能知道特定接口的作用。</p><p>以下是基本命名准则：</p><ol><li>如果只处理对象而非基本类型，名称则为 <code class="highlighter-rouge">Function</code>，<code class="highlighter-rouge">Consumer</code>，<code class="highlighter-rouge">Predicate</code> 等。参数类型通过泛型添加。</li><li>如果接收的参数是基本类型，则由名称的第一部分表示，如 <code class="highlighter-rouge">LongConsumer</code>，<code class="highlighter-rouge">DoubleFunction</code>，<code class="highlighter-rouge">IntPredicate</code> 等，但基本 <code class="highlighter-rouge">Supplier</code> 类型例外。</li><li>如果返回值为基本类型，则用 <code class="highlighter-rouge">To</code> 表示，如 <code class="highlighter-rouge">ToLongFunction </code> 和 <code class="highlighter-rouge">IntToLongFunction</code>。</li><li>如果返回值类型与参数类型一致，则是一个运算符：单个参数使用 <code class="highlighter-rouge">UnaryOperator</code>，两个参数使用 <code class="highlighter-rouge">BinaryOperator</code>。</li><li>如果接收两个参数且返回值为布尔值，则是一个谓词（Predicate）。</li><li>如果接收的两个参数类型不同，则名称中有一个 <code class="highlighter-rouge">Bi</code>。</li></ol><p>下表描述了 <code class="highlighter-rouge">java.util.function</code> 中的目标类型（包括例外情况）：</p></blockquote></li></ul><table><thead><tr><th style="text-align: left"><strong>特征</strong></th><th style="text-align: center"><strong>函数式方法名</strong></th><th style="text-align: center"><strong>示例</strong></th></tr></thead><tbody><tr><td style="text-align: left">无参数； <br /> 无返回值</td><td style="text-align: center"><strong>Runnable</strong> <br /> (java.lang) <br /> <code class="highlighter-rouge">run()</code></td><td style="text-align: center"><strong>Runnable</strong></td></tr><tr><td style="text-align: left">无参数； <br /> 返回类型任意</td><td style="text-align: center"><strong>Supplier</strong> <br /> <code class="highlighter-rouge">get()</code> <br /> <code class="highlighter-rouge">getAs类型()</code></td><td style="text-align: center"><strong>Supplier<code class="highlighter-rouge">&lt;T&gt;</code> <br /> BooleanSupplier <br /> IntSupplier <br /> LongSupplier <br /> DoubleSupplier</strong></td></tr><tr><td style="text-align: left">无参数； <br /> 返回类型任意</td><td style="text-align: center"><strong>Callable</strong> <br /> (java.util.concurrent) <br /> <code class="highlighter-rouge">call()</code></td><td style="text-align: center"><strong>Callable<code class="highlighter-rouge">&lt;V&gt;</code></strong></td></tr><tr><td style="text-align: left">1 参数； <br /> 无返回值</td><td style="text-align: center"><strong>Consumer</strong> <br /> <code class="highlighter-rouge">accept()</code></td><td style="text-align: center"><strong><code class="highlighter-rouge">Consumer&lt;T&gt;</code> <br /> IntConsumer <br /> LongConsumer <br /> DoubleConsumer</strong></td></tr><tr><td style="text-align: left">2 参数 <strong>Consumer</strong></td><td style="text-align: center"><strong>BiConsumer</strong> <br /> <code class="highlighter-rouge">accept()</code></td><td style="text-align: center"><strong><code class="highlighter-rouge">BiConsumer&lt;T,U&gt;</code></strong></td></tr><tr><td style="text-align: left">2 参数 <strong>Consumer</strong>； <br /> 1 引用； <br /> 1 基本类型</td><td style="text-align: center"><strong>Obj类型Consumer</strong> <br /> <code class="highlighter-rouge">accept()</code></td><td style="text-align: center"><strong><code class="highlighter-rouge">ObjIntConsumer&lt;T&gt;</code> <br /> <code class="highlighter-rouge">ObjLongConsumer&lt;T&gt;</code> <br /> <code class="highlighter-rouge">ObjDoubleConsumer&lt;T&gt;</code></strong></td></tr><tr><td style="text-align: left">1 参数； <br /> 返回类型不同</td><td style="text-align: center"><strong>Function</strong> <br /> <code class="highlighter-rouge">apply()</code> <br /> <strong>To类型</strong> 和 <strong>类型To类型</strong> <br /> <code class="highlighter-rouge">applyAs类型()</code></td><td style="text-align: center"><strong>Function<code class="highlighter-rouge">&lt;T,R&gt;</code> <br /> IntFunction<code class="highlighter-rouge">&lt;R&gt;</code> <br /> <code class="highlighter-rouge">LongFunction&lt;R&gt;</code> <br /> DoubleFunction<code class="highlighter-rouge">&lt;R&gt;</code> <br /> ToIntFunction<code class="highlighter-rouge">&lt;T&gt;</code> <br /> <code class="highlighter-rouge">ToLongFunction&lt;T&gt;</code> <br /> <code class="highlighter-rouge">ToDoubleFunction&lt;T&gt;</code> <br /> IntToLongFunction <br /> IntToDoubleFunction <br /> LongToIntFunction <br /> LongToDoubleFunction <br /> DoubleToIntFunction <br /> DoubleToLongFunction</strong></td></tr><tr><td style="text-align: left">1 参数； <br /> 返回类型相同</td><td style="text-align: center"><strong>UnaryOperator</strong> <br /> <code class="highlighter-rouge">apply()</code></td><td style="text-align: center"><strong><code class="highlighter-rouge">UnaryOperator&lt;T&gt;</code> <br /> IntUnaryOperator <br /> LongUnaryOperator <br /> DoubleUnaryOperator</strong></td></tr><tr><td style="text-align: left">2 参数类型相同； <br /> 返回类型相同</td><td style="text-align: center"><strong>BinaryOperator</strong> <br /> <code class="highlighter-rouge">apply()</code></td><td style="text-align: center"><strong><code class="highlighter-rouge">BinaryOperator&lt;T&gt;</code> <br /> IntBinaryOperator <br /> LongBinaryOperator <br /> DoubleBinaryOperator</strong></td></tr><tr><td style="text-align: left">2 参数类型相同; <br /> 返回整型</td><td style="text-align: center">Comparator <br /> (java.util) <br /> <code class="highlighter-rouge">compare()</code></td><td style="text-align: center"><strong><code class="highlighter-rouge">Comparator&lt;T&gt;</code></strong></td></tr><tr><td style="text-align: left">2 参数； <br /> 返回布尔型</td><td style="text-align: center"><strong>Predicate</strong> <br /> <code class="highlighter-rouge">test()</code></td><td style="text-align: center"><strong><code class="highlighter-rouge">Predicate&lt;T&gt;</code> <br /> <code class="highlighter-rouge">BiPredicate&lt;T,U&gt;</code> <br /> IntPredicate <br /> LongPredicate <br /> DoublePredicate</strong></td></tr><tr><td style="text-align: left">参数基本类型； <br /> 返回基本类型</td><td style="text-align: center"><strong>类型To类型Function</strong> <br /> <code class="highlighter-rouge">applyAs类型()</code></td><td style="text-align: center"><strong>IntToLongFunction <br /> IntToDoubleFunction <br /> LongToIntFunction <br /> LongToDoubleFunction <br /> DoubleToIntFunction <br /> DoubleToLongFunction</strong></td></tr><tr><td style="text-align: left">2 参数类型不同</td><td style="text-align: center"><strong>Bi操作</strong> <br /> (不同方法名)</td><td style="text-align: center"><strong><code class="highlighter-rouge">BiFunction&lt;T,U,R&gt;</code> <br /> <code class="highlighter-rouge">BiConsumer&lt;T,U&gt;</code> <br /> <code class="highlighter-rouge">BiPredicate&lt;T,U&gt;</code> <br /> <code class="highlighter-rouge">ToIntBiFunction&lt;T,U&gt;</code> <br /> <code class="highlighter-rouge">ToLongBiFunction&lt;T,U&gt;</code> <br /> <code class="highlighter-rouge">ToDoubleBiFunction&lt;T&gt;</code></strong></td></tr></tbody></table><ul><li><p>从 Lambda 表达式引用的局部变量必须是 <code class="highlighter-rouge">final</code> 或者是等同 <code class="highlighter-rouge">final</code> 效果的。</p></li><li><p>函数组合（Function Composition）意为“多个函数组合成新函数”。下例使用了 <code class="highlighter-rouge">Function</code> 里的 <code class="highlighter-rouge">compose()</code>和 <code class="highlighter-rouge">andThen()</code>。</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FunctionComposition</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="sc">'A'</span><span class="o">,</span> <span class="sc">'_'</span><span class="o">);</span>
    <span class="o">},</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span>
    <span class="n">f3</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(),</span>
    <span class="n">f4</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="n">f2</span><span class="o">).</span><span class="na">andThen</span><span class="o">(</span><span class="n">f3</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
      <span class="n">f4</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="s">"GO AFTER ALL AMBULANCES"</span><span class="o">));</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>输出结果：</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AFTER ALL AMBULANCES
_fter _ll _mbul_nces
</code></pre></div></div><blockquote><p>这里我们重点看正在创建的新函数 <code class="highlighter-rouge">f4</code>。它调用 <code class="highlighter-rouge">apply()</code> 的方式与常规几乎无异。</p><p>当 <code class="highlighter-rouge">f1</code> 获得字符串时，它已经被<code class="highlighter-rouge">f2</code> 剥离了前三个字符。这是因为 <code class="highlighter-rouge">compose（f2）</code> 表示 <code class="highlighter-rouge">f2</code> 的调用发生在 <code class="highlighter-rouge">f1</code> 之前。</p></blockquote><blockquote><p>以<code class="highlighter-rouge">Function</code> 里的 <code class="highlighter-rouge">compose()</code>方法为例具体说明：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="no">R</span> <span class="nf">apply</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">);</span>
<span class="o">...</span>
<span class="k">default</span> <span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">Function</span><span class="o">&lt;</span><span class="no">V</span><span class="o">,</span> <span class="no">R</span><span class="o">&gt;</span> <span class="nf">compose</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">V</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">before</span><span class="o">)</span> <span class="o">{</span>
 <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">before</span><span class="o">);</span>
 <span class="k">return</span> <span class="o">(</span><span class="no">V</span> <span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">apply</span><span class="o">(</span><span class="n">before</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">v</span><span class="o">));</span>
	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div><p>这个方法本质上是一个Function 对象调用另外一个 Function对象生成第三个 Function对象的过程，即 Function C = Function A.compose(Function B)；当 C 去执行apply( )时能联想到实际是调用Function A.compose(Function B)处理即可。</p><ol><li>接收一个名为before的Function参数，判断其不为null后return一个新函数 ；</li><li>(V v) -&gt; apply(<code class="highlighter-rouge">before.apply(v)</code>);这里的输入v是before的输入类型 V 的实例，因为before先执行；</li><li>后面的语句中先执行before的 apply(v)方法，得到结果为before的结果类型T；</li><li>然后这个结果再作为输入由compose( )方法的调用者函数（this）执行 apply(T t)，返回最终的结果类型 R 给compose( )方法的返回值 Function&lt;V,R&gt;。</li></ol><p>整个过程要注意泛型的匹配和流转，在compose( )方法中为V-&gt;T-&gt;R；</p></blockquote><blockquote><p>下例是 <code class="highlighter-rouge">Predicate</code> 的逻辑运算演示.代码示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PredicateComposition</span> <span class="o">{</span>
  <span class="kd">static</span> <span class="nc">Predicate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"bar"</span><span class="o">),</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">,</span>
    <span class="n">p3</span> <span class="o">=</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"foo"</span><span class="o">),</span>
    <span class="n">p4</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="na">negate</span><span class="o">().</span><span class="na">and</span><span class="o">(</span><span class="n">p2</span><span class="o">).</span><span class="na">or</span><span class="o">(</span><span class="n">p3</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"bar"</span><span class="o">,</span> <span class="s">"foobar"</span><span class="o">,</span> <span class="s">"foobaz"</span><span class="o">,</span> <span class="s">"fongopuckey"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">p4</span><span class="o">)</span>
      <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>​ 输出结果：</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foobar
foobaz
</code></pre></div></div><blockquote><p><code class="highlighter-rouge">p4</code> 获取到了所有断言并组合成一个更复杂的断言。解读：如果字符串中不包含 <code class="highlighter-rouge">bar</code> 且长度小于 5，或者它包含 <code class="highlighter-rouge">foo</code> ，则结果为 <code class="highlighter-rouge">true</code>。</p><p>正因它产生如此清晰的语法，我在主方法中采用了一些小技巧，并借用了下一章的内容。首先，我创建了一个字符串对象的流，然后将每个对象传递给 <code class="highlighter-rouge">filter()</code> 操作。 <code class="highlighter-rouge">filter()</code> 使用 <code class="highlighter-rouge">p4</code> 的断言来确定对象的去留。最后我们使用 <code class="highlighter-rouge">forEach()</code> 将 <code class="highlighter-rouge">println</code> 方法引用应用在每个留存的对象上。</p><p>从输出结果我们可以看到 <code class="highlighter-rouge">p4</code> 的工作流程：任何带有 <code class="highlighter-rouge">foo</code> 的东西都会留下，即使它的长度大于 5。 <code class="highlighter-rouge">fongopuckey</code> 因长度超出和不包含 <code class="highlighter-rouge">foo</code> 而被丢弃。</p></blockquote></li></ul></article><span class="tags"> 标签： <a href="/tags.html#Tij" title="Tij">#Tij</a>&nbsp; </span><div style="margin-top: 1rem;padding-left: 0;"><hr class="post-divide" /></div><div class="post-pagination"> <a class="float-left" href="/2019/10/TiJ-3.html" title="Thinking in Java摘抄（集合）">« Thinking in Java摘抄（集合）</a> <a class="float-right" href="/2019/10/TiJ-5.html" title="Thinking in Java摘抄（流式编程）">Thinking in Java摘抄（流式编程） »</a></div><div class="clearfix"></div><div id="disqus_thread"></div><script> var disqus_config = function () { this.page.url = 'http://laixinz.com//2019/10/TiJ-4.html'; this.page.identifier = '/2019/10/TiJ-4.html'; }; (function() { var d = document, s = d.createElement('script'); s.src = 'https://laixinzcom.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); </script> <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></main><div id="_backdrop"></div><a id="_menu" href="#_sidebar">☰</a><aside id="_sidebar" class="sidebar" style="background-image:url('/public/images/mountains.jpg')" ><div class="container sidebar-sticky"><div class="sidebar-about"><h1> <a href="" title="Peninsula"> Peninsula </a></h1><p>关于编程、生活、游戏和我的一些思考。</p></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">主页</a> <a class="sidebar-nav-item" href="/tags.html">标签</a> <a class="sidebar-nav-item" href="/links.html">友链</a> <a class="sidebar-nav-item" href="/about.html">关于</a></nav><div class="sidebar-social"> <a href="https://github.com/jizhizhu" title="Github" target="_blank" data-no-instant><span class="icon czs-github-logo"></span></a> <a href="/feed.xml"><span class="icon czs-rss"></span></a></div></div></aside><script src="/public/js/drawer.min.js"></script> <script src="/public/js/instantclick.min.js" data-no-instant></script> <script type="text/javascript"> $(document).ready(function () { $("p img").each(function () { var wrapA = "<a data-fancybox='gallery' href='" + this.src + "'></a>"; $(this).wrapAll(wrapA); }); }); var isLoad = false; InstantClick.on('change', function (isInitialLoad) { var blocks = document.querySelectorAll('pre code'); for (var i = 0; i < blocks.length; i++) { hljs.highlightBlock(blocks[i]); } if (isInitialLoad === false) { if (typeof ga !== 'undefined') ga('send', 'pageview', location.pathname + location.search); } if (!isLoad) { isLoad = true; $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"); } }); InstantClick.init('mousedown'); /*** * Put your custom script here */ if (navigator.platform.match(/win32/i)) { var cssId = 'webkit-scrollbar'; if (!document.getElementById(cssId)) { var head = document.getElementsByTagName('head')[0]; var style = document.createElement('style'); style.id = cssId; style.innerText = ` ::-webkit-scrollbar { width: 6px; height: 6px; background-color: #fff; } ::-webkit-scrollbar-track { background-color: #fff; } ::-webkit-scrollbar-thumb { background-color: #ccc; border: 1px solid #ddd; } `; head.appendChild(style); } } </script> <script id="dsq-count-scr" src="//laixinzcom.disqus.com/count.js" async></script></body></html>