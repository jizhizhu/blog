<!DOCTYPE html><html lang="zh-hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" /><title>Thinking in Java摘抄（字符串） | Peninsula</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Thinking in Java摘抄（字符串）" /><meta name="author" content="jizhizhu" /><meta property="og:locale" content="en_US" /><meta name="description" content="字符串" /><meta property="og:description" content="字符串" /><link rel="canonical" href="http://laixinz.com//2019/10/TiJ-8.html" /><meta property="og:url" content="http://laixinz.com//2019/10/TiJ-8.html" /><meta property="og:site_name" content="Peninsula" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-18T00:00:00+08:00" /> <script type="application/ld+json"> {"url":"http://laixinz.com//2019/10/TiJ-8.html","author":{"@type":"Person","name":"jizhizhu"},"headline":"Thinking in Java摘抄（字符串）","dateModified":"2019-10-18T00:00:00+08:00","datePublished":"2019-10-18T00:00:00+08:00","description":"字符串","mainEntityOfPage":{"@type":"WebPage","@id":"http://laixinz.com//2019/10/TiJ-8.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="stylesheet" href="/public/css/styles.css"><link rel="stylesheet" href="/public/plugins/fancybox/jquery.fancybox.min.css" media="all"><link rel="stylesheet" href="/public/fonts/caomei/style.css" media="all"><style> .content a, .related-posts li a:hover { color: #dc322f; } ::selection { color: #fff; background: #dc322f; } ::-moz-selection { color: #fff; background: #dc322f; }</style><link rel="icon" type="image/jpeg" href="/public/images/icons/launcher-icon-128x128.jpeg"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/images/icons/launcher-icon-152x152.jpeg"><link rel="alternate" type="application/feed+xml" title="Peninsula" href="/feed.xml"><link rel="manifest" href="/manifest.json"> <script src="/public/js/jquery.min.js"></script> <script src="/public/js/highlight.min.js"></script> <script src="/public/plugins/fancybox/jquery.fancybox.min.js"></script> <script async> (function (i, s, o, g, r, a, m) { i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments) }, i[r].l = 1 * new Date(); a = s.createElement(o), m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m) })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'); ga('create', '', 'auto'); ga('send', 'pageview'); </script> <script> var _hmt = _hmt || []; (function () { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script></head><body class="theme-base-08"><main class="content container"><article class="post"><h1 class="post-title">Thinking in Java摘抄（字符串）</h1><div class="post-date"> <span>发表于 <time datetime="2019-10-18T00:00:00+08:00">2019年10月18日</time> &middot;</span> 阅读量 <span id="busuanzi_value_page_pv">加载中...</span></div><hr class="post-divide"><h2 id="字符串">字符串</h2><ul><li><p><code class="highlighter-rouge">String</code>对象是不可变的。查看JDK文档你就会发现，<code class="highlighter-rouge">String</code>类中每一个看起来会修改<code class="highlighter-rouge">String</code>值的方法，实际上都是创建了一个全新的<code class="highlighter-rouge">String</code>对象,以包含修改后的字符串内容。而最初的<code class="highlighter-rouge">String</code>对象则丝毫未动。</p><p>看看下面的代码：</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// strings/Immutable.java</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Immutable</span> <span class="o">{</span> 
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">upcase</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">toUpperCase</span><span class="o">();</span> 
    <span class="o">}</span> 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
        <span class="nc">String</span> <span class="n">q</span> <span class="o">=</span> <span class="s">"howdy"</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">);</span> <span class="c1">// howdy </span>
        <span class="nc">String</span> <span class="n">qq</span> <span class="o">=</span> <span class="n">upcase</span><span class="o">(</span><span class="n">q</span><span class="o">);</span> 
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">qq</span><span class="o">);</span> <span class="c1">// HOWDY </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">);</span> <span class="c1">// howdy </span>
    <span class="o">}</span> 
<span class="o">}</span> 
<span class="cm">/* Output: 
howdy
HOWDY 
howdy
*/</span> 
</code></pre></div></div><p>当把<code class="highlighter-rouge">q</code>传递给<code class="highlighter-rouge">upcase()</code>方法时，实际传递的是引用的一个拷贝。其实，每当把String对象作为方法的参数时，都会复制一份引用，而该引用所指向的对象其实一直待在单一的物理位置上，从未动过。</p><p>回到<code class="highlighter-rouge">upcase()</code>的定义，传入其中的引用有了名字<code class="highlighter-rouge">s</code>，只有<code class="highlighter-rouge">upcase()</code>运行的时候，局部引用<code class="highlighter-rouge">s</code>才存在。一旦<code class="highlighter-rouge">upcase()</code>运行结束，<code class="highlighter-rouge">s</code>就消失了。当然了，<code class="highlighter-rouge">upcase()</code>的返回值，其实是最终结果的引用。这足以说明，<code class="highlighter-rouge">upcase()</code>返回的引用已经指向了一个新的对象，而<code class="highlighter-rouge">q</code>仍然在原来的位置。</p><p><code class="highlighter-rouge">String</code>的这种行为正是我们想要的。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"asdf"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Immutable</span><span class="o">.</span><span class="na">upcase</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
</code></pre></div></div><p>难道你真的希望<code class="highlighter-rouge">upcase()</code>方法改变其参数吗？对于一个方法而言，参数是为该方法提供信息的，而不是想让该方法改变自己的。在阅读这段代码时，读者自然会有这样的感觉。这一点很重要，正是有了这种保障，才使得代码易于编写和阅读。</p></blockquote></li><li><p>当你为一个类编写<code class="highlighter-rouge">toString()</code>方法时（或其他类似场景的字符串累加问题），如果字符串操作比较简单，那就可以信赖编译器，它会为你合理地构造最终的字符串结果。但是，如果你要在<code class="highlighter-rouge">toString()</code>方法中使用循环，且可能有性能问题，那么最好自己创建一个<code class="highlighter-rouge">StringBuilder</code>对象，用它来构建最终结果。</p></li><li><p>如果你希望<code class="highlighter-rouge">toString()</code>打印出类的内存地址，也许你会考虑使用<code class="highlighter-rouge">this</code>关键字：</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InfiniteRecursion</span> <span class="o">{</span> 
    <span class="nd">@Override</span> 
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> 
        <span class="k">return</span> <span class="s">" InfiniteRecursion address: "</span> <span class="o">+</span> <span class="k">this</span> <span class="o">+</span> <span class="s">"\n"</span>
    <span class="o">}</span> 
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
        <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nl">InfiniteRecursion:</span><span class="o">:</span><span class="k">new</span><span class="o">)</span> 
            <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span> 
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span> 
    <span class="o">}</span> 
<span class="o">}</span> 
</code></pre></div></div><p>当你创建了<code class="highlighter-rouge">InfiniteRecursion</code>对象，并将其打印出来的时候，你会得到一串很长的异常信息。如果你将该<code class="highlighter-rouge">InfiniteRecursion</code>对象存入一个<code class="highlighter-rouge">ArrayList</code>中，然后打印该<code class="highlighter-rouge">ArrayList</code>，同样也会抛出异常。其实，当运行到如下代码时：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"InfiniteRecursion address: "</span> <span class="o">+</span> <span class="k">this</span> 
</code></pre></div></div><p>这里发生了自动类型转换，由<code class="highlighter-rouge">InfiniteRecursion</code>类型转换为<code class="highlighter-rouge">String</code>类型。因为编译器发现一个<code class="highlighter-rouge">String</code>对象后面跟着一个“+”，而“+”后面的对象不是<code class="highlighter-rouge">String</code>，于是编译器试着将<code class="highlighter-rouge">this</code>转换成一个<code class="highlighter-rouge">String</code>。它怎么转换呢？正是通过调用<code class="highlighter-rouge">this</code>上的<code class="highlighter-rouge">toString()</code>方法，于是就发生了递归调用。</p><p>如果你真的想要打印对象的内存地址，应该调用<code class="highlighter-rouge">Object.toString()</code>方法，这才是负责此任务的方法。所以，不要使用<code class="highlighter-rouge">this</code>，而是应该调用<code class="highlighter-rouge">super.toString()</code>方法。</p></blockquote></li><li><p>字符串操作：以下是<code class="highlighter-rouge">String</code>对象具备的一些基本方法。重载的方法归纳在同一行中：</p><blockquote><table><thead><tr><th>方法</th><th>参数，重载版本</th><th>作用</th></tr></thead><tbody><tr><td>构造方法</td><td>默认版本，<code class="highlighter-rouge">String</code>，<code class="highlighter-rouge">StringBuilder</code>，<code class="highlighter-rouge">StringBuffer</code>，<code class="highlighter-rouge">char</code>数组，<code class="highlighter-rouge">byte</code>数组</td><td>创建<code class="highlighter-rouge">String</code>对象</td></tr><tr><td><code class="highlighter-rouge">length()</code></td><td> </td><td><code class="highlighter-rouge">String</code>中字符的个数</td></tr><tr><td><code class="highlighter-rouge">charAt()</code></td><td><code class="highlighter-rouge">int</code>索引</td><td>获取<code class="highlighter-rouge">String</code>中索引位置上的<code class="highlighter-rouge">char</code></td></tr><tr><td><code class="highlighter-rouge">getChars()</code>，<code class="highlighter-rouge">getBytes()</code></td><td>待复制部分的开始和结束索引，复制的目标数组，目标数组的开始索引</td><td>复制<code class="highlighter-rouge">char</code>或<code class="highlighter-rouge">byte</code>到一个目标数组中</td></tr><tr><td><code class="highlighter-rouge">toCharArray()</code></td><td> </td><td>生成一个<code class="highlighter-rouge">char[]</code>，包含<code class="highlighter-rouge">String</code>中的所有字符</td></tr><tr><td><code class="highlighter-rouge">equals()</code>，<code class="highlighter-rouge">equalsIgnoreCase()</code></td><td>与之进行比较的<code class="highlighter-rouge">String</code></td><td>比较两个<code class="highlighter-rouge">String</code>的内容是否相同。如果相同，结果为<code class="highlighter-rouge">true</code></td></tr><tr><td><code class="highlighter-rouge">compareTo()</code>，<code class="highlighter-rouge">compareToIgnoreCase()</code></td><td>与之进行比较的<code class="highlighter-rouge">String</code></td><td>按词典顺序比较<code class="highlighter-rouge">String</code>的内容，比较结果为负数、零或正数。注意，大小写不等价</td></tr><tr><td><code class="highlighter-rouge">contains()</code></td><td>要搜索的<code class="highlighter-rouge">CharSequence</code></td><td>如果该<code class="highlighter-rouge">String</code>对象包含参数的内容，则返回<code class="highlighter-rouge">true</code></td></tr><tr><td><code class="highlighter-rouge">contentEquals()</code></td><td>与之进行比较的<code class="highlighter-rouge">CharSequence</code>或<code class="highlighter-rouge">StringBuffer</code></td><td>如果该<code class="highlighter-rouge">String</code>对象与参数的内容完全一致，则返回<code class="highlighter-rouge">true</code></td></tr><tr><td><code class="highlighter-rouge">isEmpty()</code></td><td> </td><td>返回<code class="highlighter-rouge">boolean</code>结果，以表明<code class="highlighter-rouge">String</code>对象的长度是否为0</td></tr><tr><td><code class="highlighter-rouge">regionMatches()</code></td><td>该<code class="highlighter-rouge">String</code>的索引偏移量，另一个<code class="highlighter-rouge">String</code>及其索引偏移量，要比较的长度。重载版本增加了“忽略大小写”功能</td><td>返回<code class="highlighter-rouge">boolean</code>结果，以表明所比较区域是否相等</td></tr><tr><td><code class="highlighter-rouge">startsWith()</code></td><td>可能的起始<code class="highlighter-rouge">String</code>。重载版本在参数中增加了偏移量</td><td>返回<code class="highlighter-rouge">boolean</code>结果，以表明该<code class="highlighter-rouge">String</code>是否以传入参数开始</td></tr><tr><td><code class="highlighter-rouge">endsWith()</code></td><td>该<code class="highlighter-rouge">String</code>可能的后缀<code class="highlighter-rouge">String</code></td><td>返回<code class="highlighter-rouge">boolean</code>结果，以表明此参数是否是该字符串的后缀</td></tr><tr><td><code class="highlighter-rouge">indexOf()</code>，<code class="highlighter-rouge">lastIndexOf()</code></td><td>重载版本包括：<code class="highlighter-rouge">char</code>，<code class="highlighter-rouge">char</code>与起始索引，<code class="highlighter-rouge">String</code>，<code class="highlighter-rouge">String</code>与起始索引</td><td>如果该<code class="highlighter-rouge">String</code>并不包含此参数，就返回-1；否则返回此参数在<code class="highlighter-rouge">String</code>中的起始索引。<code class="highlighter-rouge">lastIndexOf</code>()是从后往前搜索</td></tr><tr><td><code class="highlighter-rouge">matches()</code></td><td>一个正则表达式</td><td>返回<code class="highlighter-rouge">boolean</code>结果，以表明该<code class="highlighter-rouge">String</code>和给出的正则表达式是否匹配</td></tr><tr><td><code class="highlighter-rouge">split()</code></td><td>一个正则表达式。可选参数为需要拆分的最大数量</td><td>按照正则表达式拆分<code class="highlighter-rouge">String</code>，返回一个结果数组</td></tr><tr><td><code class="highlighter-rouge">join()</code>（Java8引入的）</td><td>分隔符，待拼字符序列。用分隔符将字符序列拼接成一个新的<code class="highlighter-rouge">String</code></td><td>用分隔符拼接字符片段，产生一个新的<code class="highlighter-rouge">String</code></td></tr><tr><td><code class="highlighter-rouge">substring()</code>（即<code class="highlighter-rouge">subSequence()</code>）</td><td>重载版本：起始索引；起始索引+终止索引</td><td>返回一个新的<code class="highlighter-rouge">String</code>对象，以包含参数指定的子串</td></tr><tr><td><code class="highlighter-rouge">concat()</code></td><td>要连接的<code class="highlighter-rouge">String</code></td><td>返回一个新的<code class="highlighter-rouge">String</code>对象，内容为原始<code class="highlighter-rouge">String</code>连接上参数<code class="highlighter-rouge">String</code></td></tr><tr><td><code class="highlighter-rouge">replace()</code></td><td>要替换的字符，用来进行替换的新字符。也可以用一个<code class="highlighter-rouge">CharSequence</code>替换另一个<code class="highlighter-rouge">CharSequence</code></td><td>返回替换字符后的新<code class="highlighter-rouge">String</code>对象。如果没有替换发生，则返回原始的<code class="highlighter-rouge">String</code>对象</td></tr><tr><td><code class="highlighter-rouge">replaceFirst()</code></td><td>要替换的正则表达式，用来进行替换的<code class="highlighter-rouge">String</code></td><td>返回替换首个目标字符串后的<code class="highlighter-rouge">String</code>对象</td></tr><tr><td><code class="highlighter-rouge">replaceAll()</code></td><td>要替换的正则表达式，用来进行替换的<code class="highlighter-rouge">String</code></td><td>返回替换所有目标字符串后的<code class="highlighter-rouge">String</code>对象</td></tr><tr><td><code class="highlighter-rouge">toLowerCase()</code>，<code class="highlighter-rouge">toUpperCase()</code></td><td> </td><td>将字符的大小写改变后，返回一个新的<code class="highlighter-rouge">String</code>对象。如果没有任何改变，则返回原始的<code class="highlighter-rouge">String</code>对象</td></tr><tr><td><code class="highlighter-rouge">trim()</code></td><td> </td><td>将<code class="highlighter-rouge">String</code>两端的空白符删除后，返回一个新的<code class="highlighter-rouge">String</code>对象。如果没有任何改变，则返回原始的<code class="highlighter-rouge">String</code>对象</td></tr><tr><td><code class="highlighter-rouge">valueOf()</code>（<code class="highlighter-rouge">static</code>）</td><td>重载版本：<code class="highlighter-rouge">Object</code>；<code class="highlighter-rouge">char[]</code>；<code class="highlighter-rouge">char[]</code>，偏移量，与字符个数；<code class="highlighter-rouge">boolean</code>；<code class="highlighter-rouge">char</code>；<code class="highlighter-rouge">int</code>；<code class="highlighter-rouge">long</code>；<code class="highlighter-rouge">float</code>；<code class="highlighter-rouge">double</code></td><td>返回一个表示参数内容的<code class="highlighter-rouge">String</code></td></tr><tr><td><code class="highlighter-rouge">intern()</code></td><td> </td><td>为每个唯一的字符序列生成一个且仅生成一个<code class="highlighter-rouge">String</code>引用</td></tr><tr><td><code class="highlighter-rouge">format()</code></td><td>要格式化的字符串，要替换到格式化字符串的参数</td><td>返回格式化结果<code class="highlighter-rouge">String</code></td></tr></tbody></table><p>从这个表可以看出，当需要改变字符串的内容时，<code class="highlighter-rouge">String</code>类的方法都会返回一个新的<code class="highlighter-rouge">String</code>对象。同时，如果内容不改变，<code class="highlighter-rouge">String</code>方法只是返回原始对象的一个引用而已。这可以节约存储空间以及避免额外的开销。</p></blockquote></li><li><p>格式化输出：在长久的等待之后，Java SE5终于推出了C语言中 <code class="highlighter-rouge">printf()</code> 风格的格式化输出这一功能。这不仅使得控制输出的代码更加简单，同时也给与Java开发者对于输出格式与排列更加大的控制能力。</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Row 1: [%d %f]%n"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
</code></pre></div></div><p>这一行代码在运行的时候，首先将<code class="highlighter-rouge">x</code>的值插入到<code class="highlighter-rouge">%d</code>的位置，然后将<code class="highlighter-rouge">y</code>的值插入到<code class="highlighter-rouge">%f</code>的位置。这些占位符叫做<em>格式修饰符</em>，它们不仅指明了插入数据的位置，同时还指明了将会插入什么类型的变量，以及如何格式化。在这个例子中<code class="highlighter-rouge">%d</code>表示<code class="highlighter-rouge">x</code>是一个整数，<code class="highlighter-rouge">%f</code>表示<code class="highlighter-rouge">y</code>是一个浮点数（<code class="highlighter-rouge">float</code>或者 <code class="highlighter-rouge">double</code>）。</p><p>Java SE5引入了<code class="highlighter-rouge">format()</code>方法，可用于<code class="highlighter-rouge">PrintStream</code>或者<code class="highlighter-rouge">PrintWriter</code>对象（你可以在 <a href="https://github.com/LingCoder/OnJava8/blob/master/docs/book/18-Strings.md#"><code class="highlighter-rouge">附录:流式I/O</code></a>了解更多内容），其中也包括<code class="highlighter-rouge">System.out</code>对象。<code class="highlighter-rouge">format()</code>方法模仿了C语言的<code class="highlighter-rouge">printf()</code>。如果你比较怀旧的话，也可以使用 <code class="highlighter-rouge">printf()</code>。以下是一个简单的示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SimpleFormat</span> <span class="o">{</span>   
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>     
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>     
        <span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">5.332542</span><span class="o">;</span>     
        <span class="c1">// The old way: </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Row 1: ["</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>     
        <span class="c1">// The new way:     </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"Row 1: [%d %f]%n"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>     
        <span class="c1">// or     </span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"Row 1: [%d %f]%n"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>   
    <span class="o">}</span> 
<span class="o">}</span> 
<span class="cm">/* Output: 
Row 1: [5 5.332542] 
Row 1: [5 5.332542] 
Row 1: [5 5.332542] 
*/</span>
</code></pre></div></div><p>可以看到，<code class="highlighter-rouge">format()</code>和 <code class="highlighter-rouge">printf()</code>是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。</p><p><code class="highlighter-rouge">String</code>类也有一个<code class="highlighter-rouge">static format()</code>方法，可以格式化字符串。</p></blockquote></li><li><p>下面的表格展示了最常用的类型转换：</p><blockquote><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code class="highlighter-rouge">d</code></td><td>整型（十进制）</td></tr><tr><td><code class="highlighter-rouge">c</code></td><td>Unicode字符</td></tr><tr><td><code class="highlighter-rouge">b</code></td><td>Boolean值</td></tr><tr><td><code class="highlighter-rouge">s</code></td><td>String</td></tr><tr><td><code class="highlighter-rouge">f</code></td><td>浮点数（十进制）</td></tr><tr><td><code class="highlighter-rouge">e</code></td><td>浮点数（科学计数）</td></tr><tr><td><code class="highlighter-rouge">x</code></td><td>整型（十六进制）</td></tr><tr><td><code class="highlighter-rouge">h</code></td><td>散列码（十六进制）</td></tr><tr><td><code class="highlighter-rouge">%</code></td><td>字面值“%”</td></tr></tbody></table><p>Java SE5也参考了C中的<code class="highlighter-rouge">sprintf()</code>方法，以生成格式化的<code class="highlighter-rouge">String</code>对象。<code class="highlighter-rouge">String.format()</code>是一个<code class="highlighter-rouge">static</code>方法，它接受与<code class="highlighter-rouge">Formatter.format()</code>方法一样的参数，但返回一个<code class="highlighter-rouge">String</code>对象。当你只需使用一次<code class="highlighter-rouge">format()</code>方法的时候，<code class="highlighter-rouge">String.format()</code>用起来很方便。例如：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DatabaseException</span> <span class="kd">extends</span> <span class="nc">Exception</span> <span class="o">{</span>   
    <span class="kd">public</span> <span class="nf">DatabaseException</span><span class="o">(</span><span class="kt">int</span> <span class="n">transactionID</span><span class="o">,</span>     
      <span class="kt">int</span> <span class="n">queryID</span><span class="o">,</span> <span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>     
      <span class="kd">super</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"(t%d, q%d) %s"</span><span class="o">,</span> <span class="n">transactionID</span><span class="o">,</span>         
        <span class="n">queryID</span><span class="o">,</span> <span class="n">message</span><span class="o">));</span>   
    <span class="o">}</span>   
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>     
      <span class="k">try</span> <span class="o">{</span>       
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">DatabaseException</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="s">"Write failed"</span><span class="o">);</span>     
      <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>       
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>     
      <span class="o">}</span>   
    <span class="o">}</span> 
<span class="o">}</span> 
<span class="cm">/* 
Output: 
DatabaseException: (t3, q7) Write failed 
*/</span>
</code></pre></div></div><p>其实在<code class="highlighter-rouge">String.format()</code>内部，它也是创建了一个<code class="highlighter-rouge">Formatter</code>对象，然后将你传入的参数转给<code class="highlighter-rouge">Formatter</code>。不过，与其自己做这些事情，不如使用便捷的<code class="highlighter-rouge">String.format()</code>方法，何况这样的代码更清晰易读。</p></blockquote></li></ul></article><span class="tags"> 标签： <a href="/tags.html#Tij" title="Tij">#Tij</a>&nbsp; </span><div style="margin-top: 1rem;padding-left: 0;"><hr class="post-divide" /></div><div class="post-pagination"> <a class="float-left" href="/2019/10/TiJ-7.html" title="Thinking in Java摘抄（Files）">« Thinking in Java摘抄（Files）</a> <a class="float-right" href="/2019/10/TiJ-9.html" title="Thinking in Java摘抄（类型信息）">Thinking in Java摘抄（类型信息） »</a></div><div class="clearfix"></div></main><div id="_backdrop"></div><a id="_menu" href="#_sidebar">☰</a><aside id="_sidebar" class="sidebar" style="background-image:url('/public/images/mountains.jpg')" ><div class="container sidebar-sticky"><div class="sidebar-about"><h1> <a href="" title="Peninsula"> Peninsula </a></h1><p>关于编程、生活、游戏和我的一些思考。</p></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">主页</a> <a class="sidebar-nav-item" href="/tags.html">标签</a> <a class="sidebar-nav-item" href="/links.html">友链</a> <a class="sidebar-nav-item" href="/about.html">关于</a></nav><div class="sidebar-social"> <a href="https://github.com/jizhizhu" title="Github" target="_blank" data-no-instant><span class="icon czs-github-logo"></span></a> <a href="/feed.xml"><span class="icon czs-rss"></span></a></div></div></aside><script src="/public/js/drawer.min.js"></script> <script src="/public/js/instantclick.min.js" data-no-instant></script> <script type="text/javascript"> $(document).ready(function () { $("p img").each(function () { var wrapA = "<a data-fancybox='gallery' href='" + this.src + "'></a>"; $(this).wrapAll(wrapA); }); }); var isLoad = false; InstantClick.on('change', function (isInitialLoad) { var blocks = document.querySelectorAll('pre code'); for (var i = 0; i < blocks.length; i++) { hljs.highlightBlock(blocks[i]); } if (isInitialLoad === false) { if (typeof ga !== 'undefined') ga('send', 'pageview', location.pathname + location.search); } if (!isLoad) { isLoad = true; $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"); } }); InstantClick.init('mousedown'); /*** * Put your custom script here */ if (navigator.platform.match(/win32/i)) { var cssId = 'webkit-scrollbar'; if (!document.getElementById(cssId)) { var head = document.getElementsByTagName('head')[0]; var style = document.createElement('style'); style.id = cssId; style.innerText = ` ::-webkit-scrollbar { width: 6px; height: 6px; background-color: #fff; } ::-webkit-scrollbar-track { background-color: #fff; } ::-webkit-scrollbar-thumb { background-color: #ccc; border: 1px solid #ddd; } `; head.appendChild(style); } } </script></body></html>