<!DOCTYPE html><html lang="zh-hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" /><title>Thinking in Java摘抄（访问权限控制，复用类，多态） | Peninsula</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Thinking in Java摘抄（访问权限控制，复用类，多态）" /><meta name="author" content="jizhizhu" /><meta property="og:locale" content="en_US" /><meta name="description" content="访问权限控制" /><meta property="og:description" content="访问权限控制" /><link rel="canonical" href="http://lckclub.com//2019/10/TiJ-1.html" /><meta property="og:url" content="http://lckclub.com//2019/10/TiJ-1.html" /><meta property="og:site_name" content="Peninsula" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-10T00:00:00+08:00" /> <script type="application/ld+json"> {"url":"http://lckclub.com//2019/10/TiJ-1.html","author":{"@type":"Person","name":"jizhizhu"},"headline":"Thinking in Java摘抄（访问权限控制，复用类，多态）","dateModified":"2019-10-10T00:00:00+08:00","datePublished":"2019-10-10T00:00:00+08:00","description":"访问权限控制","mainEntityOfPage":{"@type":"WebPage","@id":"http://lckclub.com//2019/10/TiJ-1.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="stylesheet" href="/public/css/styles.css"><link rel="stylesheet" href="/public/plugins/fancybox/jquery.fancybox.min.css" media="all"><link rel="stylesheet" href="/public/fonts/caomei/style.css" media="all"><style> .content a, .related-posts li a:hover { color: #dc322f; } ::selection { color: #fff; background: #dc322f; } ::-moz-selection { color: #fff; background: #dc322f; }</style><link rel="icon" type="image/jpeg" href="/public/images/icons/launcher-icon-128x128.jpeg"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/images/icons/launcher-icon-152x152.jpeg"><link rel="alternate" type="application/feed+xml" title="Peninsula" href="/feed.xml"><link rel="manifest" href="/manifest.json"> <script src="/public/js/jquery.min.js"></script> <script src="/public/js/highlight.min.js"></script> <script src="/public/plugins/fancybox/jquery.fancybox.min.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151331959-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-151331959-1'); </script></head><body class="theme-base-08"><main class="content container"><article class="post"><h1 class="post-title">Thinking in Java摘抄（访问权限控制，复用类，多态）</h1><div class="post-date"> <span>发表于 <time datetime="2019-10-10T00:00:00+08:00">2019年10月10日</time> &middot;</span> 阅读量 <span id="busuanzi_value_page_pv">加载中...</span></div><hr class="post-divide"><h2 id="访问权限控制">访问权限控制</h2><ul><li><p>类（非内部类）访问权限仅有两个选择：包访问权限或public。</p></li><li><p>接口中的成员访问权限默认都是public。</p></li></ul><h2 id="复用">复用</h2><ul><li><p>“is-a”（是一个）用继承表达，“has-a”（有一个）用组合表达。</p></li><li><p>慎用继承：问一问自己是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的；但如果不需要，则应当好好考虑自己是否需要继承。</p></li><li><p>将一个方法指定为final,可能会妨碍其他程序员在项目中通过继承来复用你的类，而这只是因为你没有想到它会以那种方式被运用。</p></li><li><p>构造器也是static方法，尽管static关键字并没有显式地写出来。因此可以说类是在其任何static成员被访问时加载的（创建类的第一个对象，访问static域或方法）。</p></li><li><p>加载一个类时如果它有一个基类（由关键字extends得知），会先加载基类。</p></li><li><p>类加载完毕后对象就可以被创建了。顺序为</p><blockquote><p>对象的实例变量都会被设为默认值</p><p>调用基类构造器</p><p>初始化实例变量</p><p>执行自身构造器其余部分</p></blockquote></li></ul><h2 id="多态">多态</h2><ul><li><p>多态（也称作动态绑定、后期绑定或运行时绑定）：</p><p><strong>在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。</strong></p><p>多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建 <strong><em>可扩展</em></strong> 的程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序。</p><blockquote><p>“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节<strong>“私有化”</strong> 把接口和实现分离开来。 而多态的作用则是消除类型之间的耦合关系。</p></blockquote></li><li><p>将一个方法调用同一个方法主体关联起来被称作绑定。</p><blockquote><p>程序执行前进行绑定叫做前期绑定。</p><p>运行时根据对象的类型进行绑定叫做后期绑定，也称为动态绑定或运行时绑定。</p><p>java除了static方法和final方法（private方法是隐式的final方法）之外，其他所有的方法都是后期绑定。这也就意味着final可以防止其他人覆盖方法之外还可以有效地“关闭”动态绑定。</p></blockquote></li><li><p>在一个设计良好的OOP程序中，大多数或者所有方法都会只与基类接口通信。这样的程序是<strong><em>可扩展的</em></strong>，因为可以从通用的基类继承出新的数据类型，从而添加一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。</p></li><li><p>多态陷阱1：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Pitfall</span> <span class="o">{</span>
  
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"super method"</span><span class="o">);</span>
    <span class="o">}</span>
  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Pitfall</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PitfallSub</span><span class="o">();</span>
        <span class="n">p</span><span class="o">.</span><span class="na">method</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">PitfallSub</span> <span class="kd">extends</span> <span class="nc">Pitfall</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"sub method"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span><span class="cm">/* Output:
super method
*/</span><span class="c1">//:~</span>
</code></pre></div></div><blockquote><p>“覆盖”私有方法：只有非private方法才可以被覆盖；虽然编译器不会报错但也不会按照我们所期望的来执行。确切地说，在导出类中，对于基类中的private方法，最好采用不同的名字。</p></blockquote></li><li><p>多态陷阱 2：</p><blockquote><p>只有普通方法调用可以是多态的。访问field将在编译期进行解析；如果方法是static的，它的行为也不具有多态性。因为静态方法是与类，而并非与单个的对象相关联。</p></blockquote></li><li><p>继承与清理：<strong>逆序销毁</strong></p><blockquote><p>成员对象销毁的顺序应该和初始化顺序相反，以防后声明的成员依赖先声明的成员；</p><p>对于类的清理，应该首先对导出类清理，然后才是基类。这是因为导出类的清理可能会调用基类中的某些方法，所以需要使基类中的构件仍起作用而不应过早地销毁它们。</p></blockquote></li><li><p>成员变量被多个对象共享时必需使用引用计数来跟踪仍旧访问着共享对象的对象数量。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Shared</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">refcount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++;</span>
  <span class="kd">public</span> <span class="nf">Shared</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"Creating "</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addRef</span><span class="o">()</span> <span class="o">{</span> <span class="n">refcount</span><span class="o">++;</span> <span class="o">}</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">dispose</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(--</span><span class="n">refcount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">print</span><span class="o">(</span><span class="s">"Disposing "</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"Shared "</span> <span class="o">+</span> <span class="n">id</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
  
<span class="kd">class</span> <span class="nc">Composing</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Shared</span> <span class="n">shared</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="n">counter</span><span class="o">++;</span>
  <span class="kd">public</span> <span class="nf">Composing</span><span class="o">(</span><span class="nc">Shared</span> <span class="n">shared</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"Creating "</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">shared</span> <span class="o">=</span> <span class="n">shared</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">shared</span><span class="o">.</span><span class="na">addRef</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">dispose</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"disposing "</span> <span class="o">+</span> <span class="k">this</span><span class="o">);</span>
    <span class="n">shared</span><span class="o">.</span><span class="na">dispose</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="s">"Composing "</span> <span class="o">+</span> <span class="n">id</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReferenceCounting</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Shared</span> <span class="n">shared</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Shared</span><span class="o">();</span>
    <span class="nc">Composing</span><span class="o">[]</span> <span class="n">composing</span> <span class="o">=</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Composing</span><span class="o">(</span><span class="n">shared</span><span class="o">),</span>
      <span class="k">new</span> <span class="nf">Composing</span><span class="o">(</span><span class="n">shared</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Composing</span><span class="o">(</span><span class="n">shared</span><span class="o">),</span>
      <span class="k">new</span> <span class="nf">Composing</span><span class="o">(</span><span class="n">shared</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Composing</span><span class="o">(</span><span class="n">shared</span><span class="o">)</span> <span class="o">};</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">Composing</span> <span class="n">c</span> <span class="o">:</span> <span class="n">composing</span><span class="o">)</span>
      <span class="n">c</span><span class="o">.</span><span class="na">dispose</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="cm">/* Output:
Creating Shared 0
Creating Composing 0
Creating Composing 1
Creating Composing 2
Creating Composing 3
Creating Composing 4
disposing Composing 0
disposing Composing 1
disposing Composing 2
disposing Composing 3
disposing Composing 4
Disposing Shared 0
*/</span><span class="c1">//:~</span>
</code></pre></div></div></li><li><p>构建一个子类对象时，当这个对象的基类构造器中调用被子类覆盖的方法，子类在此时仍旧是没有被初始化的。<strong><em>然而被调用的动态绑定方法却会向外深入到继承层次结构内部，它可以调用子类的方法，</em></strong> 而这个子类方法所操纵的成员可能还未进行初始化——这肯定会招致灾难。 编写构造器的准则：“用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法”。在构造器内唯一能够安全调用的那些方法是基类中的final方法（也适用于private方法，它们自动属于final方法）。这些方法不能被覆盖，因此也就不会出现下述令人惊讶的问题。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Glyph</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span> <span class="n">print</span><span class="o">(</span><span class="s">"Glyph.draw()"</span><span class="o">);</span> <span class="o">}</span>
  <span class="nc">Glyph</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"Glyph() before draw()"</span><span class="o">);</span>
    <span class="n">draw</span><span class="o">();</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"Glyph() after draw()"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>	
  
<span class="kd">class</span> <span class="nc">RoundGlyph</span> <span class="kd">extends</span> <span class="nc">Glyph</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
  <span class="nc">RoundGlyph</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">radius</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"RoundGlyph.RoundGlyph(), radius = "</span> <span class="o">+</span> <span class="n">radius</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"RoundGlyph.draw(), radius = "</span> <span class="o">+</span> <span class="n">radius</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>	
  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PolyConstructors</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">RoundGlyph</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="cm">/* Output:
Glyph() before draw()
RoundGlyph.draw(), radius = 0
Glyph() after draw()
RoundGlyph.RoundGlyph(), radius = 5
*/</span><span class="c1">//:~</span>
</code></pre></div></div></li><li><p>协变返回类型：允许子类覆盖的方法返回父类方法返回值类型的子类型</p></li><li><p>使用继承设计程序时的通用准则：用继承表达行为间的差异，并用字段（组合）表达状态上的变化。</p></li></ul></article><span class="tags"> 标签： <a href="/tags.html#Tij" title="Tij">#Tij</a>&nbsp; </span><div style="margin-top: 1rem;padding-left: 0;"><hr class="post-divide" /></div><div class="post-pagination"> <a class="float-left" href="/2019/10/blog-todo.html" title="博客后期需要调整的内容">« 博客后期需要调整的内容</a> <a class="float-right" href="/2019/10/TiJ-2.html" title="Thinking in Java摘抄（接口，内部类）">Thinking in Java摘抄（接口，内部类） »</a></div><div class="clearfix"></div></main><div id="_backdrop"></div><a id="_menu" href="#_sidebar">☰</a><aside id="_sidebar" class="sidebar" style="background-image:url('/public/images/mountains.jpg')" ><div class="container sidebar-sticky"><div class="sidebar-about"><h1> <a href="" title="Peninsula"> Peninsula </a></h1><p>关于编程、生活、游戏和我的一些思考。</p></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">主页</a> <a class="sidebar-nav-item" href="/tags.html">标签</a> <a class="sidebar-nav-item" href="/links.html">友链</a> <a class="sidebar-nav-item" href="/about.html">关于</a></nav><div class="sidebar-social"> <a href="https://github.com/jizhizhu" title="Github" target="_blank" data-no-instant><span class="icon czs-github-logo"></span></a> <a href="/feed.xml"><span class="icon czs-rss"></span></a></div></div></aside><script src="/public/js/drawer.min.js"></script> <script src="/public/js/instantclick.min.js" data-no-instant></script> <script type="text/javascript"> $(document).ready(function () { $("p img").each(function () { var wrapA = "<a data-fancybox='gallery' href='" + this.src + "'></a>"; $(this).wrapAll(wrapA); }); }); var isLoad = false; InstantClick.on('change', function (isInitialLoad) { var blocks = document.querySelectorAll('pre code'); for (var i = 0; i < blocks.length; i++) { hljs.highlightBlock(blocks[i]); } if (isInitialLoad === false) { if (typeof ga !== 'undefined') ga('send', 'pageview', location.pathname + location.search); } if (!isLoad) { isLoad = true; $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"); } }); InstantClick.init('mousedown'); /*** * Put your custom script here */ if (navigator.platform.match(/win32/i)) { var cssId = 'webkit-scrollbar'; if (!document.getElementById(cssId)) { var head = document.getElementsByTagName('head')[0]; var style = document.createElement('style'); style.id = cssId; style.innerText = ` ::-webkit-scrollbar { width: 6px; height: 6px; background-color: #fff; } ::-webkit-scrollbar-track { background-color: #fff; } ::-webkit-scrollbar-thumb { background-color: #ccc; border: 1px solid #ddd; } `; head.appendChild(style); } } </script> <script id="dsq-count-scr" src="//laixinzcom.disqus.com/count.js" async></script></body></html>