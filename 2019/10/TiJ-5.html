<!DOCTYPE html><html lang="zh-hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" /><title>Thinking in Java摘抄（流式编程） | Peninsula</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Thinking in Java摘抄（流式编程）" /><meta name="author" content="jizhizhu" /><meta property="og:locale" content="en_US" /><meta name="description" content="流式编程" /><meta property="og:description" content="流式编程" /><link rel="canonical" href="https://lckclub.com//2019/10/TiJ-5.html" /><meta property="og:url" content="https://lckclub.com//2019/10/TiJ-5.html" /><meta property="og:site_name" content="Peninsula" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-12T00:00:00+08:00" /> <script type="application/ld+json"> {"url":"https://lckclub.com//2019/10/TiJ-5.html","author":{"@type":"Person","name":"jizhizhu"},"headline":"Thinking in Java摘抄（流式编程）","dateModified":"2019-10-12T00:00:00+08:00","datePublished":"2019-10-12T00:00:00+08:00","description":"流式编程","mainEntityOfPage":{"@type":"WebPage","@id":"https://lckclub.com//2019/10/TiJ-5.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="stylesheet" href="/public/css/styles.css"><link rel="stylesheet" href="/public/plugins/fancybox/jquery.fancybox.min.css" media="all"><link rel="stylesheet" href="/public/fonts/caomei/style.css" media="all"><style> .content a, .related-posts li a:hover { color: #dc322f; } ::selection { color: #fff; background: #dc322f; } ::-moz-selection { color: #fff; background: #dc322f; }</style><link rel="icon" type="image/jpeg" href="/public/images/icons/launcher-icon-128x128.jpeg"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/images/icons/launcher-icon-152x152.jpeg"><link rel="alternate" type="application/feed+xml" title="Peninsula" href="/feed.xml"><link rel="manifest" href="/manifest.json"> <script src="/public/js/jquery.min.js"></script> <script src="/public/js/highlight.min.js"></script> <script src="/public/plugins/fancybox/jquery.fancybox.min.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151331959-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-151331959-1'); </script></head><body class="theme-base-08"><main class="content container"><article class="post"><h1 class="post-title">Thinking in Java摘抄（流式编程）</h1><div class="post-date"> <span>发表于 <time datetime="2019-10-12T00:00:00+08:00">2019年10月12日</time> &middot;</span> 阅读量 <span id="busuanzi_value_page_pv">加载中...</span></div><hr class="post-divide"><h2 id="流式编程">流式编程</h2><blockquote><p>集合优化了对象的存储，而流和对象的处理有关。</p></blockquote><ul><li><p>流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说。</p><p>在大多数情况下，将对象存储在集合中是为了处理他们，因此你将会发现你将把编程的主要焦点从集合转移到了流上。流的一个核心好处是，它使得程序更加短小并且更易理解。当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体。流使得 Java 8 更具吸引力。</p><p>举个例子，假如你要随机展示 5 至 20 之间不重复的整数并进行排序。实际上，你的关注点首先是创建一个有序集合。围绕这个集合进行后续的操作。但是使用流式编程，你就可以简单陈述你想做什么：</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Randoms</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Random</span><span class="o">(</span><span class="mi">47</span><span class="o">)</span>
            <span class="o">.</span><span class="na">ints</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
            <span class="o">.</span><span class="na">distinct</span><span class="o">()</span>
            <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
            <span class="o">.</span><span class="na">sorted</span><span class="o">()</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote></li><li><p>显式地编写迭代机制称为外部迭代。而在 <code class="highlighter-rouge">Randoms.java</code> 中，流式编程采用内部迭代，这是流式编程的核心特性之一。这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。通过放弃对迭代过程的控制，我们把控制权交给并行化机制。我们将在<a href="https://github.com/LingCoder/OnJava8/blob/master/docs/book/24-Concurrent-Programming.md">并发编程</a>一章中学习这部分内容。</p><p>另一个重要方面，流是<strong><em>懒加载</em></strong>的。这代表着它只在绝对必要时才计算。你可以将流看作“延迟列表”。由于计算延迟，流使我们能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。</p></li><li><p>Java 8 在原有接口中增加流式方法而不影响现存类所采用的解决方案是：在<a href="https://github.com/LingCoder/OnJava8/blob/master/docs/book/10-Interfaces.md">接口</a>中添加被 <code class="highlighter-rouge">default</code>（<code class="highlighter-rouge">默认</code>）修饰的方法。通过这种方案，设计者们可以将流式（<em>stream</em>）方法平滑地嵌入到现有类中而不破坏原有的代码。流方法预置的操作几乎已满足了我们平常所有的需求。流操作的类型有三种：创建流，修改流元素（中间操作， Intermediate Operations），消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。</p></li><li><p>流创建：你可以通过 <code class="highlighter-rouge">Stream.of()</code> 很容易地将一组元素转化成为流（<code class="highlighter-rouge">Bubble</code> 类在本章的后面定义）：</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StreamOf</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">Bubble</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Bubble</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Bubble</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
        <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"It's "</span><span class="o">,</span> <span class="s">"a "</span><span class="o">,</span> <span class="s">"wonderful "</span><span class="o">,</span> <span class="s">"day "</span><span class="o">,</span> <span class="s">"for "</span><span class="o">,</span> <span class="s">"pie!"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">print</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mf">3.14159</span><span class="o">,</span> <span class="mf">2.718</span><span class="o">,</span> <span class="mf">1.618</span><span class="o">)</span>
            <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>输出结果：</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bubble(1)
Bubble(2)
Bubble(3)
It's a wonderful day for pie!
3.14159
2.718
1.618
</code></pre></div></div></li><li><p><strong>Stream.</strong><code class="highlighter-rouge">generate()</code> 可以把任意 <code class="highlighter-rouge">Supplier&lt;T&gt;</code> 用于生成 <code class="highlighter-rouge">T</code> 类型的流（调用<code class="highlighter-rouge">Supplier</code>的get( )方法获取元素）。</p></li><li><p><strong>Stream.</strong><code class="highlighter-rouge">iterate()</code> 以种子（第一个参数）开头，并将其传给方法（第二个参数）。方法的结果将添加到流，并存储作为第一个参数用于下次调用 <code class="highlighter-rouge">iterate()</code>，依次类推。我们可以利用 <code class="highlighter-rouge">iterate()</code> 生成一个斐波那契数列。代码示例：</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Fibonacci</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    
    <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="nf">numbers</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">iterate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
        <span class="o">});</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">new</span> <span class="nf">Fibonacci</span><span class="o">().</span><span class="na">numbers</span><span class="o">()</span>
                       <span class="o">.</span><span class="na">skip</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span> <span class="c1">// 过滤前 20 个</span>
                       <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span> <span class="c1">// 然后取 10 个</span>
                       <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="err">输出结果：</span>

<span class="mi">6765</span>
<span class="mi">10946</span>
<span class="mi">17711</span>
<span class="mi">28657</span>
<span class="mi">46368</span>
<span class="mi">75025</span>
<span class="mi">121393</span>
<span class="mi">196418</span>
<span class="mi">317811</span>
<span class="mi">514229</span>
</code></pre></div></div></blockquote><p>斐波那契数列将数列中最后两个元素进行求和以产生下一个元素。<code class="highlighter-rouge">iterate()</code> 只能记忆上一次操作的结果，因此我们需要利用一个变量 <code class="highlighter-rouge">x</code> 追踪另外一个元素（上上一次操作的结果）。</p><p>在主方法中，我们使用了一个之前没有见过的 <code class="highlighter-rouge">skip()</code> 操作。它根据参数丢弃指定数量的流元素。在这里，我们丢弃了前 20 个元素。</p></li><li><p>java8中流创建方式：</p><blockquote><p>每个集合都可以通过调用 <code class="highlighter-rouge">stream()</code> 方法来产生一个流；</p><p>Random类创建随机数流；</p><p><code class="highlighter-rouge">IntStream</code> 类提供了静态 <code class="highlighter-rouge">range()</code> 方法用于生成整型序列的流；</p><p>建造者模式 Stream.Builder创建流；</p><p><code class="highlighter-rouge">Arrays</code> 类中含有一个名为 <code class="highlighter-rouge">stream()</code> 的静态方法用于把数组转换成为流；</p><p><code class="highlighter-rouge">java.util.regex.Pattern</code> 中增加了一个新的方法 <code class="highlighter-rouge">splitAsStream()</code>。这个方法可以根据传入的公式将字符序列转化为流。但是有一个限制，输入只能是 <strong>CharSequence</strong>，因此不能将流作为 <code class="highlighter-rouge">splitAsStream()</code> 的参数。</p></blockquote></li><li><p>中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。</p><blockquote><p>跟踪和调试：<code class="highlighter-rouge">peek()</code> 操作的目的是帮助调试。它允许你无修改地查看流中的元素。</p><p>流元素排序：在 <code class="highlighter-rouge">Randoms.java</code> 中，我们熟识了 <code class="highlighter-rouge">sorted()</code> 的默认比较器实现。其实它还有另一种形式的实现：传入一个 <strong>Comparator</strong> 参数。</p><p>移除元素：</p><ul><li><p><code class="highlighter-rouge">distinct()</code>：在 <code class="highlighter-rouge">Randoms.java</code> 类中的 <code class="highlighter-rouge">distinct()</code> 可用于消除流中的重复元素。相比创建一个 <strong>Set</strong> 集合，该方法的工作量要少得多。</p></li><li><p><code class="highlighter-rouge">filter(Predicate)</code>：过滤操作会保留与传递进去的过滤器函数计算结果为 <code class="highlighter-rouge">true</code> 元素。</p></li></ul><p>应用函数到元素：</p><ul><li><code class="highlighter-rouge">map(Function)</code>：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</li><li><code class="highlighter-rouge">mapToInt(ToIntFunction)</code>：操作同上，但结果是 <strong>IntStream</strong>。</li><li><code class="highlighter-rouge">mapToLong(ToLongFunction)</code>：操作同上，但结果是 <strong>LongStream</strong>。</li><li><code class="highlighter-rouge">mapToDouble(ToDoubleFunction)</code>：操作同上，但结果是 <strong>DoubleStream</strong>。</li></ul><p>在 map() 中组合流：<code class="highlighter-rouge">flatMap()</code> 做了两件事：将产生流的函数应用在每个元素上（与 <code class="highlighter-rouge">map()</code> 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。</p><ul><li><code class="highlighter-rouge">flatMap(Function)</code>：当 <code class="highlighter-rouge">Function</code> 产生流时使用。</li><li><code class="highlighter-rouge">flatMapToInt(Function)</code>：当 <code class="highlighter-rouge">Function</code> 产生 <code class="highlighter-rouge">IntStream</code> 时使用。</li><li><code class="highlighter-rouge">flatMapToLong(Function)</code>：当 <code class="highlighter-rouge">Function</code> 产生 <code class="highlighter-rouge">LongStream</code> 时使用。</li><li><code class="highlighter-rouge">flatMapToDouble(Function)</code>：当 <code class="highlighter-rouge">Function</code> 产生 <code class="highlighter-rouge">DoubleStream</code> 时使用。</li></ul></blockquote></li><li><p>在我们学习终端操作之前，我们必须考虑如果你在一个空流中获取元素会发生什么。我们喜欢为了“happy path”而将流连接起来，并假设流不会被中断。在流中放置 <code class="highlighter-rouge">null</code> 是很好的中断方法。那么是否有某种对象，可作为流元素的持有者，即使查看的元素不存在也能友好地提示我们（也就是说，不会发生异常）？</p><p><strong>Optional</strong> 可以实现这样的功能。一些标准流操作返回 <strong>Optional</strong> 对象，因为它们并不能保证预期结果一定存在。包括：</p><blockquote><ul><li><code class="highlighter-rouge">findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li><li><code class="highlighter-rouge">findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li><li><p><code class="highlighter-rouge">max()</code> 和 <code class="highlighter-rouge">min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></p></li><li><p><code class="highlighter-rouge">reduce()</code> 不再以 <code class="highlighter-rouge">identity</code> 形式开头，而是将其返回值包装在 <strong>Optional</strong> 中。（<code class="highlighter-rouge">identity</code> 对象成为其他形式的 <code class="highlighter-rouge">reduce()</code> 的默认结果，因此不存在空结果的风险）</p></li><li>对于数字流 <strong>IntStream</strong>、<strong>LongStream</strong> 和 <strong>DoubleStream</strong>，<code class="highlighter-rouge">average()</code> 会将结果包装在 <strong>Optional</strong> 以防止流为空。</li></ul></blockquote></li><li><p>当你接收到 <strong>Optional</strong> 对象时，应首先调用 <code class="highlighter-rouge">isPresent()</code> 检查其中是否包含元素。如果存在，可使用 <code class="highlighter-rouge">get()</code> 获取。</p></li><li><p>有许多便利函数可以解包 <strong>Optional</strong> ，这简化了上述“对所包含的对象的检查和执行操作”的过程：</p><blockquote><ul><li><code class="highlighter-rouge">ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li><li><code class="highlighter-rouge">orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>。</li><li><code class="highlighter-rouge">orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li><li><code class="highlighter-rouge">orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li></ul></blockquote></li><li><p>当我们在自己的代码中加入 <strong>Optional</strong> 时，可以使用下面 3 个静态方法：</p><blockquote><ul><li><code class="highlighter-rouge">empty()</code>：生成一个空 <strong>Optional</strong>。</li><li><code class="highlighter-rouge">of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li><li><code class="highlighter-rouge">ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li></ul></blockquote></li><li><p>当我们的流管道生成了 <strong>Optional</strong> 对象，下面 3 个方法可使得 <strong>Optional</strong> 的后续能做更多的操作：</p><blockquote><ul><li><p><code class="highlighter-rouge">filter(Predicate)</code>：将 <strong>Predicate</strong> 应用于 <strong>Optional</strong> 中的内容并返回结果。当 <strong>Optional</strong> 不满足 <strong>Predicate</strong> 时返回空。如果 <strong>Optional</strong> 为空，则直接返回。</p></li><li><p><code class="highlighter-rouge">map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong> 于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。</p></li><li><p><code class="highlighter-rouge">flatMap(Function)</code>：同 <code class="highlighter-rouge">map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code class="highlighter-rouge">flatMap()</code> 不会在最后进行任何包装。</p><p>以上方法都不适用于数值型 <strong>Optional</strong>。一般来说，流的 <code class="highlighter-rouge">filter()</code> 会在 <strong>Predicate</strong> 返回 <code class="highlighter-rouge">false</code> 时移除流元素。而 <code class="highlighter-rouge">Optional.filter()</code> 在失败时不会删除 <strong>Optional</strong>，而是将其保留下来，并转化为空。</p></li></ul></blockquote></li><li><p>终端操作：这些操作接收一个流并产生一个最终结果；它们不会向后端流提供任何东西。因此，终端操作总是你在管道中做的最后一件事情。</p><blockquote><p>转化为数组：</p><ul><li><p><code class="highlighter-rouge">toArray()</code>：将流转换成适当类型的数组。</p></li><li><p><code class="highlighter-rouge">toArray(generator)</code>：在特殊情况下，生成器用于分配自定义的数组存储。</p><p>这组方法在流操作产生的结果必须是数组形式时很有用。假如我们想在流里复用获取的随机数，可以将他们保存到数组中。</p></li></ul><p>应用最终操作：</p><ul><li><p><code class="highlighter-rouge">forEach(Consumer)</code>：你已经看到过很多次 <code class="highlighter-rouge">System.out::println</code> 作为 <strong>Consumer</strong> 函数。</p></li><li><p><code class="highlighter-rouge">forEachOrdered(Consumer)</code>： 保证 <code class="highlighter-rouge">forEach</code> 按照原始流顺序操作。</p><p>第一种形式：显式设计为任意顺序操作元素，仅在引入 <code class="highlighter-rouge">parallel()</code> 操作时才有意义。在 <a href="https://github.com/LingCoder/OnJava8/blob/master/docs/book/24-Concurrent-Programming.md">并发编程</a> 章节之前我们不会深入研究这个问题。这里简单介绍下 <code class="highlighter-rouge">parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。因为我们采用的是内部迭代，而不是外部迭代，所以这是可能实现的。</p><p><code class="highlighter-rouge">parallel()</code> 看似简单，实则棘手。更多内容将在稍后的 <a href="https://github.com/LingCoder/OnJava8/blob/master/docs/book/24-Concurrent-Programming.md">并发编程</a> 章节中学习。</p><p>下例引入了 <code class="highlighter-rouge">parallel()</code> 来帮助理解 <code class="highlighter-rouge">forEachOrdered(Consumer)</code> 的作用和使用场景。代码示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streams/ForEach.java</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">streams</span><span class="o">.</span><span class="na">RandInts</span><span class="o">.*;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ForEach</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SZ</span> <span class="o">=</span> <span class="mi">14</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">rands</span><span class="o">().</span><span class="na">limit</span><span class="o">(</span><span class="no">SZ</span><span class="o">)</span>
                <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d "</span><span class="o">,</span> <span class="n">n</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="n">rands</span><span class="o">().</span><span class="na">limit</span><span class="o">(</span><span class="no">SZ</span><span class="o">)</span>
                <span class="o">.</span><span class="na">parallel</span><span class="o">()</span>
                <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d "</span><span class="o">,</span> <span class="n">n</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="n">rands</span><span class="o">().</span><span class="na">limit</span><span class="o">(</span><span class="no">SZ</span><span class="o">)</span>
                <span class="o">.</span><span class="na">parallel</span><span class="o">()</span>
                <span class="o">.</span><span class="na">forEachOrdered</span><span class="o">(</span><span class="n">n</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%d "</span><span class="o">,</span> <span class="n">n</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">RandInts</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">rints</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">47</span><span class="o">).</span><span class="na">ints</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1000</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">100</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">IntStream</span> <span class="nf">rands</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">rints</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="err">输出结果：</span>
  
<span class="mi">258</span> <span class="mi">555</span> <span class="mi">693</span> <span class="mi">861</span> <span class="mi">961</span> <span class="mi">429</span> <span class="mi">868</span> <span class="mi">200</span> <span class="mi">522</span> <span class="mi">207</span> <span class="mi">288</span> <span class="mi">128</span> <span class="mi">551</span> <span class="mi">589</span>
<span class="mi">551</span> <span class="mi">861</span> <span class="mi">429</span> <span class="mi">589</span> <span class="mi">200</span> <span class="mi">522</span> <span class="mi">555</span> <span class="mi">693</span> <span class="mi">258</span> <span class="mi">128</span> <span class="mi">868</span> <span class="mi">288</span> <span class="mi">961</span> <span class="mi">207</span>
<span class="mi">258</span> <span class="mi">555</span> <span class="mi">693</span> <span class="mi">861</span> <span class="mi">961</span> <span class="mi">429</span> <span class="mi">868</span> <span class="mi">200</span> <span class="mi">522</span> <span class="mi">207</span> <span class="mi">288</span> <span class="mi">128</span> <span class="mi">551</span> <span class="mi">589</span>
</code></pre></div></div><p>​ 为了方便测试不同大小的数组，我们抽离出了 <code class="highlighter-rouge">SZ</code> 变量。结果很有趣：在第一个流中，未使用 <code class="highlighter-rouge">parallel()</code> ，所以 <code class="highlighter-rouge">rands()</code> 按照元素迭代出现的顺序显示结果；在第二个流中，引入<code class="highlighter-rouge">parallel()</code> ，即便流很小，输出的结果顺序也和前面不一样。这是由于多处理器并行操作的原因。多次运行测试，结果均不同。多处理器并行操作带来的非确定性因素造成了这样的结果。</p><p>在最后一个流中，同时使用了 <code class="highlighter-rouge">parallel()</code> 和 <code class="highlighter-rouge">forEachOrdered()</code> 来强制保持原始流顺序。因此，对非并行流使用 <code class="highlighter-rouge">forEachOrdered()</code> 是没有任何影响的。</p></li></ul><p>收集：</p><ul><li><p><code class="highlighter-rouge">collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Collectors 里面没有特定的 toTreeSet()，但是我们可以通过将集合的构造函数引用传递给 Collectors.toCollection()，从而构建任何类型的集合。</span>
<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words2</span> <span class="o">=</span>
                <span class="nc">Files</span><span class="o">.</span><span class="na">lines</span><span class="o">(</span><span class="nc">Paths</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"TreeSetOfWords.java"</span><span class="o">))</span>
                        <span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"\\W+"</span><span class="o">)))</span>
                        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">s</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="s">"\\d+"</span><span class="o">))</span> <span class="c1">// No numbers</span>
                        <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">String:</span><span class="o">:</span><span class="n">trim</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toCollection</span><span class="o">(</span><span class="nl">TreeSet:</span><span class="o">:</span><span class="k">new</span><span class="o">));</span>
</code></pre></div></div></li><li><p><code class="highlighter-rouge">collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素包含到结果中，第三个参数 <strong>BiConsumer</strong> 用于将两个值组合起来。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span>
                <span class="nc">FileToWords</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="s">"Cheese.dat"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nl">ArrayList:</span><span class="o">:</span><span class="k">new</span><span class="o">,</span>
                                <span class="nl">ArrayList:</span><span class="o">:</span><span class="n">add</span><span class="o">,</span>
                                <span class="nl">ArrayList:</span><span class="o">:</span><span class="n">addAll</span><span class="o">);</span>
</code></pre></div></div><p>在这里我们只是简单介绍了几个 <strong>Collectors</strong> 的运用示例。实际上，它还有一些非常复杂的操作实现，可通过查看 <code class="highlighter-rouge">java.util.stream.Collectors</code> 的 API 文档了解。例如，我们可以将元素收集到任意一种特定的集合中。</p></li></ul><p>组合所有流元素：</p><ul><li><p><code class="highlighter-rouge">reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</p></li><li><p><code class="highlighter-rouge">reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</p></li><li><p><code class="highlighter-rouge">reduce(identity, BiFunction, BinaryOperator)</code>：这个形式更为复杂（所以我们不会介绍它），在这里被提到是因为它使用起来会更有效。通常，你可以显式地组合 <code class="highlighter-rouge">map()</code> 和 <code class="highlighter-rouge">reduce()</code> 来更简单的表达它。</p><p>如下是一个用于演示 <code class="highlighter-rouge">reduce()</code> 的示例：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// streams/Reduce.java</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.stream.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Frobnitz</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
    <span class="nc">Frobnitz</span><span class="o">(</span><span class="kt">int</span> <span class="n">sz</span><span class="o">)</span> <span class="o">{</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sz</span><span class="o">;</span> <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Frobnitz("</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="s">")"</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// Generator:</span>
    <span class="kd">static</span> <span class="nc">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">47</span><span class="o">);</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">BOUND</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
    <span class="kd">static</span> <span class="nc">Frobnitz</span> <span class="nf">supply</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Frobnitz</span><span class="o">(</span><span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="no">BOUND</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Reduce</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stream</span><span class="o">.</span><span class="na">generate</span><span class="o">(</span><span class="nl">Frobnitz:</span><span class="o">:</span><span class="n">supply</span><span class="o">)</span>
                <span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
                <span class="o">.</span><span class="na">peek</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">)</span>
                <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">fr0</span><span class="o">,</span> <span class="n">fr1</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">fr0</span><span class="o">.</span><span class="na">size</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="o">?</span> <span class="n">fr0</span> <span class="o">:</span> <span class="n">fr1</span><span class="o">)</span>
                <span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Lambda 表达式中的第一个参数 <code class="highlighter-rouge">fr0</code> 是上一次调用 <code class="highlighter-rouge">reduce()</code> 的结果。而第二个参数 <code class="highlighter-rouge">fr1</code> 是从流传递过来的值。</p><p><code class="highlighter-rouge">reduce()</code> 中的 Lambda 表达式使用了三元表达式来获取结果，当其 size 小于 50 的时候获取 <code class="highlighter-rouge">fr0</code> 否则获取序列中的下一个值 <code class="highlighter-rouge">fr1</code>。因此你会取得第一个 size 小于 50 的 <code class="highlighter-rouge">Frobnitz</code>，只要找到了就这个结果就会紧紧地攥住它，即使有其他候选者出现。虽然这是一个非常奇怪的约束，但是它确实让你对 <code class="highlighter-rouge">reduce()</code> 有了更多的了解。</p></li></ul><p>匹配：</p><ul><li><code class="highlighter-rouge">allMatch(Predicate)</code> ：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 true 时，结果返回为 true。这个操作将会在第一个 false 之后短路；也就是不会在发生 false 之后继续执行计算。</li><li><code class="highlighter-rouge">anyMatch(Predicate)</code>：如果流中的任意一个元素根据提供的 <strong>Predicate</strong> 返回 true 时，结果返回为 true。这个操作将会在第一个 true 之后短路；也就是不会在发生 true 之后继续执行计算。</li><li><code class="highlighter-rouge">noneMatch(Predicate)</code>：如果流的每个元素根据提供的 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。这个操作将会在第一个 true 之后短路；也就是不会在发生 true 之后继续执行计算。</li></ul><p>元素查找：</p><ul><li><p><code class="highlighter-rouge">findFirst()</code>：返回一个含有第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</p></li><li><p><code class="highlighter-rouge">findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</p><p><code class="highlighter-rouge">findFirst()</code> 无论流是否为并行化的，总是会选择流中的第一个元素。对于非并行流，<code class="highlighter-rouge">findAny()</code>会选择流中的第一个元素（即使从定义上来看是选择任意元素）。在这个例子中，我们使用 <code class="highlighter-rouge">parallel()</code> 来并行流从而引入 <code class="highlighter-rouge">findAny()</code> 选择非第一个流元素的可能性。</p><p>如果必须选择流中最后一个元素，那就使用 <code class="highlighter-rouge">reduce()</code>：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="nc">OptionalInt</span> <span class="n">last</span> <span class="o">=</span> <span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
                <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">orElse</span><span class="o">(-</span><span class="mi">1</span><span class="o">));</span>
        <span class="c1">// Non-numeric object:</span>
        <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">lastobj</span> <span class="o">=</span>
                <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">reduce</span><span class="o">((</span><span class="n">n1</span><span class="o">,</span> <span class="n">n2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">n2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                <span class="n">lastobj</span><span class="o">.</span><span class="na">orElse</span><span class="o">(</span><span class="s">"Nothing there!"</span><span class="o">));</span>
</code></pre></div></div><p><code class="highlighter-rouge">reduce()</code> 的参数只是用最后一个元素替换了最后两个元素，最终只生成最后一个元素。如果为数字流，你必须使用相近的数字 <strong>Optional</strong> 类型（ numeric optional type），否则使用 <strong>Optional</strong> 类型，就像上例中的 <code class="highlighter-rouge">Optional</code>。</p></li></ul><p>信息：</p><ul><li><p><code class="highlighter-rouge">count()</code>：流中的元素个数。</p></li><li><p><code class="highlighter-rouge">max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素。</p></li><li><p><code class="highlighter-rouge">min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</p><p><code class="highlighter-rouge">min()</code> 和 <code class="highlighter-rouge">max()</code> 的返回类型为 <strong>Optional</strong>。</p></li></ul><p>数字流信息：</p><ul><li><code class="highlighter-rouge">average()</code> ：求取流元素平均值。</li><li><code class="highlighter-rouge">max()</code> 和 <code class="highlighter-rouge">min()</code>：因为这些操作在数字流上面，所以不需要 <strong>Comparator</strong>。</li><li><code class="highlighter-rouge">sum()</code>：对所有流元素进行求和。</li><li><code class="highlighter-rouge">summaryStatistics()</code>：生成可能有用的数据。目前还不太清楚他们为什么觉得有必要这样做，因为你可以使用直接的方法产生所有的数据。</li></ul></blockquote></li></ul></article><span class="tags"> 标签： <a href="/tags.html#Tij" title="Tij">#Tij</a>&nbsp; </span><div style="margin-top: 1rem;padding-left: 0;"><hr class="post-divide" /></div><div class="post-pagination"> <a class="float-left" href="/2019/10/TiJ-4.html" title="Thinking in Java摘抄（函数式编程）">« Thinking in Java摘抄（函数式编程）</a> <a class="float-right" href="/2019/10/TiJ-6.html" title="Thinking in Java摘抄（异常）">Thinking in Java摘抄（异常） »</a></div><div class="clearfix"></div></main><div id="_backdrop"></div><a id="_menu" href="#_sidebar">☰</a><aside id="_sidebar" class="sidebar" style="background-image:url('/public/images/mountains.jpg')" ><div class="container sidebar-sticky"><div class="sidebar-about"><h1> <a href="" title="Peninsula"> Peninsula </a></h1><p>关于编程、生活、游戏和我的一些思考。</p></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">主页</a> <a class="sidebar-nav-item" href="/tags.html">标签</a> <a class="sidebar-nav-item" href="/links.html">友链</a> <a class="sidebar-nav-item" href="/about.html">关于</a></nav><div class="sidebar-social"> <a href="https://github.com/jizhizhu" title="Github" target="_blank" data-no-instant><span class="icon czs-github-logo"></span></a> <a href="/feed.xml"><span class="icon czs-rss"></span></a></div></div></aside><script src="/public/js/drawer.min.js"></script> <script src="/public/js/instantclick.min.js" data-no-instant></script> <script type="text/javascript"> $(document).ready(function () { $("p img").each(function () { var wrapA = "<a data-fancybox='gallery' href='" + this.src + "'></a>"; $(this).wrapAll(wrapA); }); }); var isLoad = false; InstantClick.on('change', function (isInitialLoad) { var blocks = document.querySelectorAll('pre code'); for (var i = 0; i < blocks.length; i++) { hljs.highlightBlock(blocks[i]); } if (isInitialLoad === false) { if (typeof ga !== 'undefined') ga('send', 'pageview', location.pathname + location.search); } if (!isLoad) { isLoad = true; $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"); } }); InstantClick.init('mousedown'); /*** * Put your custom script here */ if (navigator.platform.match(/win32/i)) { var cssId = 'webkit-scrollbar'; if (!document.getElementById(cssId)) { var head = document.getElementsByTagName('head')[0]; var style = document.createElement('style'); style.id = cssId; style.innerText = ` ::-webkit-scrollbar { width: 6px; height: 6px; background-color: #fff; } ::-webkit-scrollbar-track { background-color: #fff; } ::-webkit-scrollbar-thumb { background-color: #ccc; border: 1px solid #ddd; } `; head.appendChild(style); } } </script> <script id="dsq-count-scr" src="//laixinzcom.disqus.com/count.js" async></script></body></html>