<!DOCTYPE html><html lang="zh-hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;" /><title>Thinking in Java摘抄（集合） | Peninsula</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Thinking in Java摘抄（集合）" /><meta name="author" content="jizhizhu" /><meta property="og:locale" content="en_US" /><meta name="description" content="持有对象" /><meta property="og:description" content="持有对象" /><link rel="canonical" href="http://lckclub.com//2019/10/TiJ-3.html" /><meta property="og:url" content="http://lckclub.com//2019/10/TiJ-3.html" /><meta property="og:site_name" content="Peninsula" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-10-12T00:00:00+08:00" /> <script type="application/ld+json"> {"url":"http://lckclub.com//2019/10/TiJ-3.html","author":{"@type":"Person","name":"jizhizhu"},"headline":"Thinking in Java摘抄（集合）","dateModified":"2019-10-12T00:00:00+08:00","datePublished":"2019-10-12T00:00:00+08:00","description":"持有对象","mainEntityOfPage":{"@type":"WebPage","@id":"http://lckclub.com//2019/10/TiJ-3.html"},"@type":"BlogPosting","@context":"https://schema.org"}</script><link rel="stylesheet" href="/public/css/styles.css"><link rel="stylesheet" href="/public/plugins/fancybox/jquery.fancybox.min.css" media="all"><link rel="stylesheet" href="/public/fonts/caomei/style.css" media="all"><style> .content a, .related-posts li a:hover { color: #dc322f; } ::selection { color: #fff; background: #dc322f; } ::-moz-selection { color: #fff; background: #dc322f; }</style><link rel="icon" type="image/jpeg" href="/public/images/icons/launcher-icon-128x128.jpeg"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/images/icons/launcher-icon-152x152.jpeg"><link rel="alternate" type="application/feed+xml" title="Peninsula" href="/feed.xml"><link rel="manifest" href="/manifest.json"> <script src="/public/js/jquery.min.js"></script> <script src="/public/js/highlight.min.js"></script> <script src="/public/plugins/fancybox/jquery.fancybox.min.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-151331959-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-151331959-1'); </script></head><body class="theme-base-08"><main class="content container"><article class="post"><h1 class="post-title">Thinking in Java摘抄（集合）</h1><div class="post-date"> <span>发表于 <time datetime="2019-10-12T00:00:00+08:00">2019年10月12日</time> &middot;</span> 阅读量 <span id="busuanzi_value_page_pv">加载中...</span></div><hr class="post-divide"><h2 id="持有对象">持有对象</h2><ul><li><p>可以直接使用 <code class="highlighter-rouge">Arrays.asList()</code> 的输出作为一个 <strong>List</strong> ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 <strong>List</strong> 上调用 <code class="highlighter-rouge">add()</code> 或 <code class="highlighter-rouge">remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误。</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Snow</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Powder</span> <span class="kd">extends</span> <span class="nc">Snow</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Light</span> <span class="kd">extends</span> <span class="nc">Powder</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Heavy</span> <span class="kd">extends</span> <span class="nc">Powder</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Crusty</span> <span class="kd">extends</span> <span class="nc">Snow</span> <span class="o">{}</span>
<span class="kd">class</span> <span class="nc">Slush</span> <span class="kd">extends</span> <span class="nc">Snow</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AsListInference</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Snow</span><span class="o">&gt;</span> <span class="n">snow1</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">Crusty</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Slush</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Powder</span><span class="o">());</span>
    <span class="c1">//- snow1.add(new Heavy()); // Exception</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Snow</span><span class="o">&gt;</span> <span class="n">snow2</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">Light</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Heavy</span><span class="o">());</span>
    <span class="c1">//- snow2.add(new Slush()); // Exception</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Snow</span><span class="o">&gt;</span> <span class="n">snow3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="nc">Collections</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">snow3</span><span class="o">,</span>
      <span class="k">new</span> <span class="nf">Light</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Heavy</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Powder</span><span class="o">());</span>
    <span class="n">snow3</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Crusty</span><span class="o">());</span>

    <span class="c1">// Hint with explicit type argument specification:</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Snow</span><span class="o">&gt;</span> <span class="n">snow4</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.&lt;</span><span class="nc">Snow</span><span class="o">&gt;</span><span class="n">asList</span><span class="o">(</span>
       <span class="k">new</span> <span class="nf">Light</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Heavy</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Slush</span><span class="o">());</span>
    <span class="c1">//- snow4.add(new Powder()); // Exception</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>在 <strong>snow4</strong> 中，注意 <code class="highlighter-rouge">Arrays.asList()</code> 中间的“暗示”（即 <code class="highlighter-rouge">&lt;Snow&gt;</code> ），告诉编译器 <code class="highlighter-rouge">Arrays.asList()</code> 生成的结果 <strong>List</strong> 类型的实际目标类型是什么。这称为<em>显式类型参数说明</em>（explicit type argument specification）。</p><p>java8中编译器已经可以自动识别正确的类型，无需指定显式类型参数了。</p></li><li><p><strong>List</strong>s承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p><p>有两种类型的 <strong>List</strong> ：</p><ul><li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li><li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</li></ul></li><li><p>当确定元素是否是属于某个 <strong>List</strong> contains()，寻找某个元素的索引indexOf()，以及通过引用从 <strong>List</strong> 中删除元素时remove()，都会用到 <code class="highlighter-rouge">equals()</code> 方法（根类 <strong>Object</strong> 的一个方法）。</p></li><li><p>subList()<code class="highlighter-rouge"> 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 </code>containsAll()<code class="highlighter-rouge"> 方法时，很自然地会得到 **true**。请注意，顺序并不重要，在 **sub** 上调用直观命名的 </code>Collections.sort()<code class="highlighter-rouge"> 和 </code>Collections.shuffle()<code class="highlighter-rouge"> 方法，不会影响 </code>containsAll()<code class="highlighter-rouge"> 的结果。 </code>subList()` 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。</p></li><li><p><code class="highlighter-rouge">retainAll()</code> 方法实际上是一个“集合交集”操作，它保留了同时存在的所有元素。请再次注意，所产生的结果行为依赖于 <code class="highlighter-rouge">equals()</code> 方法。</p></li><li>Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：<ol><li>使用 <code class="highlighter-rouge">iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li><li>使用 <code class="highlighter-rouge">next()</code> 方法获得序列中的下一个元素。</li><li>使用 <code class="highlighter-rouge">hasNext()</code> 方法检查序列中是否还有元素。</li><li>使用 <code class="highlighter-rouge">remove()</code> 方法将迭代器最近返回的那个元素删除。</li></ol></li><li><p><strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构(ArrayList,LinkedList,HashSet,TreeSet等等)分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p></li><li><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它还可以生成相对于迭代器在列表中指向的当前位置的后一个和前一个元素的索引，并且可以使用 <code class="highlighter-rouge">set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code class="highlighter-rouge">listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code class="highlighter-rouge">listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。</p></li><li><p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p><p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p><ul><li><code class="highlighter-rouge">getFirst()</code> 和 <code class="highlighter-rouge">element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code class="highlighter-rouge">peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code class="highlighter-rouge">removeFirst()</code> 和 <code class="highlighter-rouge">remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code class="highlighter-rouge">poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code class="highlighter-rouge">addFirst()</code> 在列表的开头插入一个元素。</li><li><code class="highlighter-rouge">offer()</code> 与 <code class="highlighter-rouge">add()</code> 和 <code class="highlighter-rouge">addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li><li><code class="highlighter-rouge">removeLast()</code> 删除并返回列表的最后一个元素。</li></ul></li><li><p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法。</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StackTest</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="s">"My dog has fleas"</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">))</span>
      <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* Output:
fleas has dog My
*/</span>
</code></pre></div></div></blockquote></li><li><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p><p><strong>Set</strong> 具有与 <strong>Collection</strong> 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 <strong>List</strong> 那样。实际上， <strong>Set</strong> 就是一个 <strong>Collection</strong> ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为。）</p></li><li><p>队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在<a href="https://github.com/LingCoder/OnJava8/blob/master/docs/book">并发编程</a>中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。</p><p><strong>LinkedList</strong> 实现了 <strong>Queue</strong> 接口，并且提供了一些方法以支持队列行为，因此 <strong>LinkedList</strong> 可以用作 <strong>Queue</strong> 的一种实现。</p></li><li><p>当在 <strong>PriorityQueue</strong> 上调用 <code class="highlighter-rouge">offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。默认的排序使用队列中对象的<em>自然顺序</em>（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code class="highlighter-rouge">peek()</code> ， <code class="highlighter-rouge">poll()</code> 或 <code class="highlighter-rouge">remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p><blockquote><p><strong>PriorityQueue</strong> 是允许重复的，最小的值具有最高的优先级（如果是 <strong>String</strong> ，空格也可以算作值，并且比字母的优先级高）。</p><p><code class="highlighter-rouge">Collections.reverseOrder()</code> （Java 5 中新添加的）可以产生反序的 <strong>Comparator</strong> 。</p><p><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</p></blockquote></li><li><p>当需要实现一个不是 <strong>Collection</strong> 的外部类时，由于让它去实现 <strong>Collection</strong> 接口可能非常困难或麻烦，因此使用 <strong>Iterator</strong> 就会变得非常吸引人。例如，如果我们通过继承一个持有 <strong>Pet</strong> 对象的类来创建一个 <strong>Collection</strong> 的实现，那么我们必须实现 <strong>Collection</strong> 所有的方法，即使我们不在 <code class="highlighter-rouge">display()</code> 方法中使用它们，也必须这样做。虽然这可以通过继承 <strong>AbstractCollection</strong> 而很容易地实现，但是无论如何还是要被强制去实现 <code class="highlighter-rouge">iterator()</code> 和 <code class="highlighter-rouge">size()</code> 方法，这些方法 <strong>AbstractCollection</strong> 没有实现，但是 <strong>AbstractCollection</strong> 中的其它方法会用到。</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CollectionSequence</span>
<span class="kd">extends</span> <span class="nc">AbstractCollection</span><span class="o">&lt;</span><span class="nc">Pet</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Pet</span><span class="o">[]</span> <span class="n">pets</span> <span class="o">=</span> <span class="nc">Pets</span><span class="o">.</span><span class="na">array</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">pets</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Pet</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Pet</span><span class="o">&gt;()</span> <span class="o">{</span> <span class="c1">// [1]</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">pets</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="nc">Pet</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">pets</span><span class="o">[</span><span class="n">index</span><span class="o">++];</span> <span class="o">}</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// Not implemented</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">CollectionSequence</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CollectionSequence</span><span class="o">();</span>
    <span class="nc">InterfaceVsIterator</span><span class="o">.</span><span class="na">display</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="nc">InterfaceVsIterator</span><span class="o">.</span><span class="na">display</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="na">iterator</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug
7:Manx
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug
7:Manx
*/</span>
</code></pre></div></div></blockquote><p>上面这个例子表明，如果实现了 <strong>Collection</strong> ，就必须实现 <code class="highlighter-rouge">iterator()</code> ，并且只拿实现 <code class="highlighter-rouge">iterator()</code> 与继承 <strong>AbstractCollection</strong> 相比，花费的代价只有略微减少。但是，如果类已经继承了其他的类，那么就不能继承再 <strong>AbstractCollection</strong> 了。在这种情况下，要实现 <strong>Collection</strong> ，就必须实现该接口中的所有方法。此时，继承并提供创建迭代器的能力要容易得多。</p><blockquote><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">PetSequence</span> <span class="o">{</span>
  <span class="kd">protected</span> <span class="nc">Pet</span><span class="o">[]</span> <span class="n">pets</span> <span class="o">=</span> <span class="nc">Pets</span><span class="o">.</span><span class="na">array</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NonCollectionSequence</span> <span class="kd">extends</span> <span class="nc">PetSequence</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Pet</span><span class="o">&gt;</span> <span class="nf">iterator</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">Pet</span><span class="o">&gt;()</span> <span class="o">{</span>
      <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">pets</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="nc">Pet</span> <span class="nf">next</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">pets</span><span class="o">[</span><span class="n">index</span><span class="o">++];</span> <span class="o">}</span>
      <span class="nd">@Override</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span> <span class="c1">// Not implemented</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">UnsupportedOperationException</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">};</span>
  <span class="o">}</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">NonCollectionSequence</span> <span class="n">nc</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nf">NonCollectionSequence</span><span class="o">();</span>
    <span class="nc">InterfaceVsIterator</span><span class="o">.</span><span class="na">display</span><span class="o">(</span><span class="n">nc</span><span class="o">.</span><span class="na">iterator</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div></blockquote><p>生成 <strong>Iterator</strong> 是将序列与消费该序列的方法连接在一起耦合度最小的方式，并且与实现 <strong>Collection</strong> 相比，它在序列类上所施加的约束也少得多。</p></li><li><p><em>for-in</em> 语法主要用于数组，但它也适用于任何 <strong>Collection</strong> 对象。这样做的原因是 Java 5 引入了一个名为 <strong>Iterable</strong> 的接口，该接口包含一个能够生成 <strong>Iterator</strong> 的 <code class="highlighter-rouge">iterator()</code> 方法。<em>for-in</em> 使用此 <strong>Iterable</strong> 接口来遍历序列。因此，如果创建了任何实现了 <strong>Iterable</strong> 的类，都可以将它用于 <em>for-in</em> 语句中。</p><blockquote><p><em>for-in</em> 语句适用于数组或其它任何 <strong>Iterable</strong> ，但这并不意味着数组肯定也是个 <strong>Iterable</strong> ，也不会发生任何自动装箱：尝试将数组作为一个 <strong>Iterable</strong> 参数传递会导致失败。这说明不存在任何从数组到 <strong>Iterable</strong> 的自动转换; 必须手工执行这种转换。</p></blockquote></li><li>如果由 <code class="highlighter-rouge">Arrays.asList()</code> 生成的 <strong>List</strong> 被直接打乱，那么它将修改底层数组。重要的是要注意 <code class="highlighter-rouge">Arrays.asList()</code> 生成一个 <strong>List</strong> 对象，该对象使用底层数组作为其物理实现。如果执行的操作会修改这个 <strong>List</strong> ，并且不希望修改原始数组，那么就应该在另一个集合中创建一个副本。</li></ul></article><span class="tags"> 标签： <a href="/tags.html#Tij" title="Tij">#Tij</a>&nbsp; </span><div style="margin-top: 1rem;padding-left: 0;"><hr class="post-divide" /></div><div class="post-pagination"> <a class="float-left" href="/2019/10/TiJ-2.html" title="Thinking in Java摘抄（接口，内部类）">« Thinking in Java摘抄（接口，内部类）</a> <a class="float-right" href="/2019/10/TiJ-4.html" title="Thinking in Java摘抄（函数式编程）">Thinking in Java摘抄（函数式编程） »</a></div><div class="clearfix"></div></main><div id="_backdrop"></div><a id="_menu" href="#_sidebar">☰</a><aside id="_sidebar" class="sidebar" style="background-image:url('/public/images/mountains.jpg')" ><div class="container sidebar-sticky"><div class="sidebar-about"><h1> <a href="" title="Peninsula"> Peninsula </a></h1><p>关于编程、生活、游戏和我的一些思考。</p></div><nav class="sidebar-nav"> <a class="sidebar-nav-item" href="/">主页</a> <a class="sidebar-nav-item" href="/tags.html">标签</a> <a class="sidebar-nav-item" href="/links.html">友链</a> <a class="sidebar-nav-item" href="/about.html">关于</a></nav><div class="sidebar-social"> <a href="https://github.com/jizhizhu" title="Github" target="_blank" data-no-instant><span class="icon czs-github-logo"></span></a> <a href="/feed.xml"><span class="icon czs-rss"></span></a></div></div></aside><script src="/public/js/drawer.min.js"></script> <script src="/public/js/instantclick.min.js" data-no-instant></script> <script type="text/javascript"> $(document).ready(function () { $("p img").each(function () { var wrapA = "<a data-fancybox='gallery' href='" + this.src + "'></a>"; $(this).wrapAll(wrapA); }); }); var isLoad = false; InstantClick.on('change', function (isInitialLoad) { var blocks = document.querySelectorAll('pre code'); for (var i = 0; i < blocks.length; i++) { hljs.highlightBlock(blocks[i]); } if (isInitialLoad === false) { if (typeof ga !== 'undefined') ga('send', 'pageview', location.pathname + location.search); } if (!isLoad) { isLoad = true; $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"); } }); InstantClick.init('mousedown'); /*** * Put your custom script here */ if (navigator.platform.match(/win32/i)) { var cssId = 'webkit-scrollbar'; if (!document.getElementById(cssId)) { var head = document.getElementsByTagName('head')[0]; var style = document.createElement('style'); style.id = cssId; style.innerText = ` ::-webkit-scrollbar { width: 6px; height: 6px; background-color: #fff; } ::-webkit-scrollbar-track { background-color: #fff; } ::-webkit-scrollbar-thumb { background-color: #ccc; border: 1px solid #ddd; } `; head.appendChild(style); } } </script> <script id="dsq-count-scr" src="//laixinzcom.disqus.com/count.js" async></script></body></html>